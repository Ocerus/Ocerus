\begin{description}
  \item[Namespaces:] Utils, Reflection
  \item[Headers:] the Utils directory
  \item[Source files:] the Utils directory
  \item[Classes:] Array, DataContainer, GlobalProperties, Singleton, StateMachine, StringKey, Timer, AbstractProperty, Property, PropertyFunctionParameter, PropertyFunctionParameters, PropertyHolder, PropertyList, TypedProperty, RTTI, RTTINullClass, RTTIBaseClass, RTTIGlue
  \item[Libraries used:] none
\end{description}


\section{Introduction}
During the development of a game you usually need several helper classes and methods such as those for math or containers. This kind of stuff does not fit anywhere because it is too general. Placing it in a specific subsystem would make it unusable anywhere else. So it is best to aggregate this in one place.



\section{Categories}
There are several categories of utilities: containers (i.e. tree), math functions (i.e. hash) and design patterns (i.e. singleton). The utilities are usually simple enough to understand, so it's best to read the code and/or the doxygen documentation. However, a few of them are a bit more complicated. That's why they're described in the following sections.


\subsection{RTTI}
RTTI is a shortage for \emph{Run-Time Type Information}. It is a mechanism which allows an instance of a class to know what its class is, the name of the class and other attributes. The instance is also able to create new instances of the same class, cloning itself.

RTTI is implemented using C++ templates. To make a use of it you must derive your class from \emph{RTTIGlue} which takes two template arguments. The first one is your class and the second one is its predecessor in the RTTI hierarchy. If there is none or you do not want to specify that inherit \emph{RTTIBaseClass} instead of \emph{RTTIGlue}. The mechanism will automatically call the static \emph{RegisterReflection} function of your class if defined. The function is called only once during the startup. Here you may adjust attributes of the class or add new ones.


\subsection{Properties}
\emph{Properties} are special \emph{RTTI} attributes of classes which allow accessing data of their instances using string names. This greatly helps encapsulating classes and provides an uniform data access interface.

To make use of \emph{Properties} your class must be already using \emph{RTTI}. Create a getter and setter method for each of your data you want to provide as properties. Define the static \emph{RegisterReflection} function (see the RTTI section for details) and inside its body call \emph{RegisterProperty} providing pointers to the data getters and setters. For details about this function see the doxygen docs. To access the data of an instance use \verb'GetRTTI()->GetProperty()' on the instance. It will give you \emph{PropertyHolder} on which you can finally call the templatized \emph{GetValue} or \emph{SetValue} methods.

You can also set a custom function as a special property. The function must take \emph{PropertyFunctionParameters} as a single parameter and return \verb'void'. You can register it using \emph{RegisterFunction}. The function can be then used in a similar way as the common properties, but you use \emph{CallFunction} instead of \emph{SetValue}.


%\section{Glossary}
%This is a glossary of the most used terms in the previous sections:
%
%\begin{description}
%  \item[Resource] -- a unit of data the game will be working with as a whole. The data is usually stored in an external device.
%\end{description}


%\begin{thebibliography}{9}                                                                                                
%\bibitem {angelscript}AngelScript documentation, file /AngelScript/index.html
%\end{thebibliography}
