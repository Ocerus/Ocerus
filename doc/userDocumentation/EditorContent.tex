\begin{description}
  \item[Namespaces:] Editor, GUISystem
  \item[Headers:] EditorGUI.h, EditorMenu.h, EditorMgr.h, FolderSelector.h, LayerMgrWidget.h, PopupMenu.h, PrototypeWindow.h, ResourceWindow\-.h and editors of properties
  \item[Source files:] EditorGUI.cpp, EditorMenu.cpp, EditorMgr.cpp, FolderSelector.cpp, LayerMgrWidget.cpp, PopupMenu.cpp, PrototypeWindow\-.cpp, ResourceWindow.cpp and editors of properties
  \item[Classes:] EditorGUI, EditorMenu, EditorMgr, FolderSelector, LayerMgrWidget, PopupMenu, PrototypeWindow, ResourceWindow
  \item[Libraries used:] CEGUI, SDL
\end{description}

\section{Purpose of the editor}

The editor is used for an easy creation of a new game based on this engine. It provides a well-arranged graphic user interface for managing everything from the whole project to each entity in several scenes. The main advantage is that every change made to a scene is immediately visible in the game window where the game action can be started anytime.

In the following sections the usage of the editor to make a new game as well as the classes providing the editor will be described. In the last section there is a small glossary of used terms.

\section{Using the editor}
\label{sec:editor-using}

\subsection{Managing projects}

\subsection{Managing scenes}

\subsection{Managing entities}

\subsection{Editor tools}

\section{Description of editor classes}

In this section the classes providing the editor will be described. They do not have to be contained in the final distribution of the game if an editor support should not be allowed. First subsection is focused on the logical and graphical managers of the editor whereas the second subsection is about layouts used to built the GUI of the editor.

\subsection{Editor managers}

The \emph{Editor::EditorMgr} class manages the logical part of the editor and it owns an instance of the \emph{Editor::EditorGUI} class that focuses to the GUI of the editor. Both of them have methods called at the loading and the unloading of the editor and also methods for updating logic and drawing in the application loop.

The first mentioned class manages the editing of entities. It manages selecting entities and editing the current one, it reacts on choosing all items in the entity submenu such as creating a new entity, duplicating and deleting current or selected entities, adding and removing entity components or creating a prototype from a current entity and it solves changing an entity name or an entity property. It also provides a function for all edit tools such as moving, rotating or scaling of a chosen entity and for resuming, pausing and restarting the game action. Finally there are methods handling all popup menus.

The second class compounds all editor layouts such as the game and editor viewports, the resource, prototype and layer windows and the editor menu and initializes and updates them. It directly updates the entity editor window according to the current entity that uses the vertical layout for positioning entity components and various value editors for showing and editing all kinds of entity properties such as strings, vectors, resources and arrays.

\subsection{Writing own value editors}

All value editors derives from the \emph{Editor::AbstractValueEditor} base class. This class has three abstract methods that every value editor must implement and some methods that can help with the implementation. The first is the \emph{AbstractValueEditor::CreateWidget} method with the parameter representing a string that should be used as a prefix for a name of every created component. This method should create a widget for editing a required kind of value and return it. The second is the \emph{AbstractValueEditor::Update} method which is called when the current value of the property should be displayed in the value editor and the last is the \emph{AbstractValueEditor::Submit} method which is called when the value of the property should be updated by the user input to the value editor.

For easier implementation of value editors the model classes with the \emph{Editor::IValueEditorModel} class as the base class were created. From the accessors of this class value editors should get the name and tool-tip for the edited property, whether the property is valid, read only, element of a list or removable and also they should be able to remove the property if is possible. It is recommended to derive own models from the \emph{Editor::ITypedValueEditor\-Model$<$T$>$} template class that also defines the getter and setter for the value of the edited property.

For example the \emph{Editor::StringEditor} class derives directly from the \emph{Editor::AbstractValueEditor} class and implements a simple editor for properties which values are easily convertible from and to string which contains a label with a property name, an edit box for displaying and editing the value and a remove button if the property is removable (i.e. as a part of an array). It uses a model derived from the \emph{Editor::ITypedValueEditorModel$<$string$>$} class to create a widget, update and submit the value which is specified in the constructor parameter. A useful implementation of this model is the \emph{Editor::StringPropertyModel} class that operates with the \emph{Reflection::Property\-Holder} class from which it gets all necessary information and which it can modify with a new value.

There are another examples of value editors and its models in the code that can help with a creation of further ones such as editors for arrays, resources etc.

\subsection{Used layouts}

There are several layouts implemented for the editor that can be used as examples of a creation of an own layout. The \emph{GUISystem::FolderSelector} class represents the layout for selecting a folder and has methods for showing/hiding it, registering callback for the Ok/Cancel pushing and getting the current and selected folder. The \emph{Editor::PopupMenu} class manages all popup menus in the editor and has methods for opening/closing it, for initializing it and for handling all menu choices.

There are three layout classes for editor components. All of them have initialization and update methods and callbacks for significant events. All of them loads their look from an external XML file and introduces the reactions on events and loading data from the application. The \emph{Editor::LayerMgrWid\-get} manages the layers the entities are put to, the \emph{Editor::PrototypeWindow} manages the prototypes of entities and the \emph{Editor::ResourceWindow} manages the resources that the entities can use.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Project] -- represents one game created in the editor that can be run independently, it is divided to scenes
  \item[Scene] -- represents one part of the game that is loaded at once (i.e. a game level, a game menu etc.)
  \item[Entity] -- represents one object in the scene with specific properties and behavior
\end{description}