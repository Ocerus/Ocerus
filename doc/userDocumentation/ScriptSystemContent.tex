\noindent\textbf{Namespaces:} ScriptSystem

\noindent\textbf{Headers:} ScriptMgr.h, ScriptRegister.h, ScriptResource.h

\noindent\textbf{Source files:} ScriptMgr.cpp, ScriptRegister.cpp, ScriptResource.cpp

\noindent\textbf{Classes:} ScriptMgr, ScriptResource

\noindent\textbf{Libraries used:} AngelScript

\section{Purpose of the script system}

The script system allows customizing reactions to application events such as messages sent to entities or GUI interactions without a compilation of a whole application to the users of the engine. The advantage of using scripts is an easier extension of the application which can be done even by non-professional users because in the script environment they cannot do any fatal errors that can corrupt the application and it is possible to have a full control of the script execution -- for example timeout of execution prevents cycling. The disadvantage is a slower execution of scripts than a native code so an user should decide which part of system will be native coded and which can be done by scripts.

In the following sections the basics of the script language will be described as well as the connection of the script system to the rest of the engine and there will be also mentioned a process of using and extending it. In the last section there is a small glossary of used terms.

\section{Introduction to the used script language}
\label{script-language}

This section is an introduction to principles and a syntax of the script language used for the writing scripts in this engine. The script language resembles C++ language but there is some differences and limitations which are described in the next paragraphs. For further information see AngelScript documentation \cite{angelscript}.

It is not possible to declare function prototypes, nor is it necessary as the compiler can resolve the function names anyway. For parameters sent by reference it is convenient to specify in which direction the value is passed (\verb/&in/ for passing to function, \verb/&out/ for passing from function and \verb/&inout/ for both directions) and whether is constant (\verb/const/ before type) because the compiler can optimize the calling.

It is possible to declare script classes like in C++ but there are no visibility keywords (everything is public) and all class methods must be declared with their implementation (like in Java or C\#). Operator overloads are supported. Only the single inheritance is allowed but polymorphism is supported by implementing interfaces and every class method is virtual. The automatic memory management is used so it can be difficult to know exactly when the destructor is called but it is called only once.

Because pointers are not safe in a scripted environment the object handles (\verb/class@ object;/) are used instead. They behave like smart pointers that control the life time of the object they hold. There are initialized to \verb/null/ by default and can be compared by \verb/is/ operator (\verb/if (a is null)/ \verb/@a = @b;/). Every object of a script class is created as a reference type while the objects of a registered class can be created as a value type (see section \ref{script-registering} for more information).

Primitive data types are same as in the game engine (for example \verb/uint8/ for unsigned 8-bit integer, \verb/float64/ for 64-bit real number). Arrays are zero based and resizeable (they have methods \verb/length()/ and \verb/resize(uint32)/). It is also possible to define C++ like enumerations and typedefs (only for primitive types).

\section{Linking the script system to the engine}

This section is about linking the script system to the rest of the application. The script system consist of the script engine to which every class and function must be registered if it should be used from script. The engine manages script modules and contexts. The script module consists of one or more files that are connected with include directives and are builded together. The name of module is the same as the name of file that includes the rest files. The script context wraps the function calling. When the application wants to call a function from a script it must create the script context, prepare it with a function ID got from the function declaration and the name of the module where the function is, add function parameters, execute it, get the return values and release it.

\subsection{Interface of the script manager}

The script manager is represented by the class \emph{ScriptSystem::ScriptMgr} that encapsulates the script engine and manages an access to the script modules. This class is a singleton and it is created when the game starts. It initializes the AngelScript engine and registers all integral classes and functions (see \ref{sub:script-registered}) as well as all user-defined ones (see \ref{script-registering}).

The first thing a caller of a script function must do is to obtain a function ID. It can be get from the method \emph{ScriptMgr::GetFunctionID} that needs the name of the module where the function is and its declaration. For example if the name of function to be called is ``IncreaseArgument'' and it receives one integer argument and returns also an integer, the declaration of it will be ``int32 IncreaseArgument(int32)''. The method returns the integer that means the desired function ID (greater than or equal to zero) or the error code (less than zero) which means the function with this declaration could not be find in the mentioned module or this module does not exist or cannot be builded from sources (see log for further information). The function ID is valid all time the module exists in memory so it can be stored for later usage.

The function mentioned above calls \emph{ScriptMgr::GetModule} to obtain desired module. This method returns the module from a memory or loads its sources from disc and builds it if necessary. If it is inconvenient that the module is builded at the first call of its function, this method can be called before to get a confidence that the module is ready to use.

%There are two ways of calling script functions. The first one is used when the script function should be called entire at once and the caller needs the return value of it. It can done with two methods.
The calling of script functions can be done with three methods. First the caller calls the \emph{ScriptMgr::PrepareContext} which needs function ID and returns context prepared for passing the argument values. Then the argument values can be passed with the \emph{SetFunctionArgument} method which needs the prepared context as the first argument, a parameter index as the second one and a parameter value in form of the \emph{PropertyFunctionParameter} as the last one. After that the \emph{ScriptMgr::ExecuteContext} should be called with the prepared context as the first argument and a maximum time of executing script to prevent cycling as the second one. This method executes the script with given arguments and returns whether the execution was successful. If so it is possible to get return value of function with corresponding methods of context. In the end the context should be released to avoid memory leaks.

%The second way of calling script function is used when it should run for a longer time with breaks caused by calling sleep and yield functions. In this case contexts are created within the context manager and they are executed by it subsequently when the \emph{ScriptMgr::ExecuteScripts} method is called which should be done in a game loop. Script functions are added to context manager by \emph{ScriptMgr::AddContextToManager} and \emph{Script\-Mgr\-::\-Add\-Context\-As\-Co\-Routine\-To\-Manager\-} which both needs a function ID as a parameter and returns context prepared for passing arguments. The first method adds the context as a new thread independent of others whereas the second one adds it as co-routine to the context passed by parameter which means when one of the co-routined contexts calls the yield function then the next context in queue will resume executing. The context added to the manager is released by itself when it finishes its execution.

There is a possibility to call a simple script string stored in a memory by the method \emph{ScriptMgr::ExecuteString} which accepts this string as the first parameter. The method wraps it to the function without parameters and builds it and calls it as a part of the module specified in the second optional parameter so it is possible to declare local variables and to call functions from the module. This is useful for example for implementing a user console.

As mentioned in the section \ref{script-language} it is possible to use a conditional compilation of scripts. The method \emph{ScriptMgr::DefineWord} adds a pre-processor define passed as the string argument. The last two methods of this class are \emph{ScriptMgr::UnloadModule} and \emph{ScriptMgr::ClearModules} that unload one/all previously loaded and builded modules and abort all contexts in context manager. All function IDs and contexts associated with these modules will be superseded so the caller should inform all objects that holds them about it (use \emph{ResourceUnloadCallback} in ScriptRegister.cpp for specify actions done when modules are unloaded). These methods could be called when it is needed to reload modules or free all memory used by them but when it is better not to destroy the whole script engine.

\subsection{Binding the entity system}
\label{script-entity}

The script system is binded to the entity system to provide an easy work with components, entities and theirs properties from scripts. The class \emph{EntityHandle} is registered to the script engine as a value type with a most of its methods but the work with entity properties differs from using them from a source code. There are registered common methods of this class for all defined property types (in \emph{PropertyTypes.h}) to get and set a simple property value, to get a non-constant or constant array and to call a property function with parameters. Methods for working with array property values (get and set a size of array, an index operator) and property function parameters (add a simple or array value as a property function parameter) are also registered. See table \ref{tab:script-properties} for method declarations.

\begin{table}[htbp]
	\centering
		{\scriptsize 
		\begin{tabular}{|p{0.38\hsize}|p{0.55\hsize}|}
			\hline
			An action & A declaration\\
			\hline
			\multicolumn{2}{|c|}{\emph{EntityHandle} methods}\\
			\hline
			Get a simple property value & \verb/type Get_type(string& property_name)/\\
			Set a simple property value & \verb/void Set_type(string& property_name, type value)/\\
			Get a non-constant array property value & \verb/array_type Get_array_type(string& property_name)/\\
			Get a constant array property value & \verb/const array_type Get_const_array_type/ \verb/  (string& property_name)/\\
			Call an entity function & \verb/void CallFunction(string& function_name,/ \verb/  PropertyFunctionParameters& parameters)/\\
			\hline
			\multicolumn{2}{|c|}{\emph{array\_type} methods}\\
			\hline
			Get a size of array & \verb/int32 GetSize() const/\\
			Set a size of non-constant array & \verb/void Resize(int32 size)/\\
			An index for a constant array & \verb/type operator[](int32 index) const/\\
			An index for a non-constant array & \verb/type& operator[](int32 index)/\\
			\hline
			\multicolumn{2}{|c|}{\emph{PropertyFunctionParameters} methods}\\
			\hline
			Add a simple property as a property function parameter & \verb/PropertyFunctionParameters operator<</ \verb/  (const type& value)/\\
			Add an array property as a property function parameter & \verb/PropertyFunctionParameters operator<</ \verb/  (const array_type& value)/\\
			\hline
		\end{tabular}
		}
	\caption[Working with entity properties]{Declarations of methods for working with entity properties where type means simple property type from \emph{PropertyTypes.h}}
	\label{tab:script-properties}
\end{table}

For example if an entity represented by its handle, that can be get from \verb/GetCurrentEntityHandle/ global function when script is handling a message to entity (see section \ref{script-component} for details), has an integer property \verb/Integer/ then the command to save it to an integer script variable will be following: \verb/int32 n = GetCurrentEntityHandle().Get_int32("Integer")/. If the property \verb/Integer/ does not exist in this entity or has an other type than \verb/int32/ the error message is written to the log and the default value (for \verb/int32/ 0) is returned.

For managing entities the \emph{EntityMgr} class is registered as no-handle object which means that only way to use it is calling methods on the return value from \verb/GetEntityMgr/ global function. For example if the script should destroy the entity represented by the variable \verb/handle/, the code will be following: \verb/GetEntityMgr().DestroyEntity(handle)/. For creation of entities the \emph{EntityDescription} class is registered as a value type, where it is possible to specify contained components, name, kind etc., as well as method \emph{CreateEntity} of \emph{EntityMgr} which has this class as parameter and returns handle of created entity.

\subsection{Registered classes and functions}
\label{sub:script-registered}

Beside the classes from the entity system mentioned in the section \ref{script-entity}, other base classes and functions are registered to the script engine. For storing a text data there are two classes registered as a value type. The first one is a standard C++ \emph{string} class registered with a most of its method, the second one is a class \emph{StringKey} which is an integer representation of text for faster comparing and assignment and which can be construct from \emph{string} and which can be cast to \emph{string} by the \emph{ToString} method.

%For a thread and co-routine support there are registered three global functions which should be used when the context is executed by the context manager. The function \verb/void sleep(uint32 time)/ suspends the script execution for at least \verb/time/ milliseconds so contexts in the other threads can be executed. The function \verb/void createCoRoutine(const string& declaration)/ creates a co-routine to the current context that calls the script function in the same module without parameters with the declaration equal to the parameter of this function. The function \verb/void yield()/ suspends the current script execution and executes the next co-routine from the same thread. For example calling the last two function subsequently means that the co-routine is created and immediately executed while the current execution is suspended waiting for the co-routine function calling \verb/yield()/.

The only registered global function is the \verb/void Log(string& message)/ function which prints the string in the parameter to the log so it is useful for debugging scripts. For a complete reference of registered classes, global functions etc. see ScriptRegister.pdf.

\section{Using and extending the script system}

This section is about using the script system and extending it. If a new property type is added to the entity system or a new system which should be accessible from scripts is created then it is necessary to register new classes and functions to the script system. For better understanding of the script system the sample component which provides a script handling of messages to entities was created and it is described in this section.

\subsection{Registering new classes and functions}
\label{script-registering}

If it is necessary to register a new class with its methods or a global function, the registration function should be implemented in the \emph{ScriptRegister.cpp} file and called by the global function \emph{RegisterAllAdditions} with the pointer to script engine as a parameter because a registration is done by calling methods of it.

The registration function should first declare the integer variable \verb/int32 r/ to which should be assign all return values from calling registration methods and after each calling the \verb/OC_SCRIPT_ASSERT()/ should be used to check if the registration is successful (it checks the variable \verb/r/ to be positive). First it is necessary to register the whole class which is done by the \emph{RegisterObjectType} method. The first parameter is a name of class in a script, the second is a size of class (use \verb/sizeof(class)/ for register a class as value, \verb/0/ otherwise) and the last parameter is flag. See table \ref{tab:script-objecttype} or documentation of AngelScript \cite{angelscript} for some flag combination.

\begin{table}[htbp]
	\centering
		{\scriptsize
		\begin{tabular}{|p{0.43\hsize}|p{0.50\hsize}|}
		\hline
		A class type & Flags\\
		\hline
		A primitive value type without any special management & \verb/asOBJ_VALUE | asOBJ_POD | asOBJ_APP_CLASS_CA/\\
		A value type needed to be properly initialized and uninitialized & \verb/asOBJ_VALUE | asOBJ_APP_CLASS_CA/\\
		A basic reference type & \verb/asOBJ_REF/\\
		A single-reference type (singleton) & \verb/asOBJ_REF | asOBJ_NOHANDLE/\\
		\hline
		\end{tabular}
		}
	\caption{Flags in register function method}
	\label{tab:script-objecttype}
\end{table}

After the registration the whole class it is possible to register methods of it with the \emph{RegisterObjectMethod} method. The first parameter is the name of the registered class, the second is the declaration of method in a script, the third is a pointer to the C++ function that should be called and the last is the calling convention. The pointer to C++ function should be get from one of the four macros described in the table \ref{tab:script-macros} (\verb/PR/ variants must be used when functions or methods are overloaded) and the possible calling conventions are listed in the table \ref{tab:script-conventions}. For example the registering of method \emph{bool EntityHandle::IsValid() const} as a method of the \verb/EntityHandle/ script class the code will be following:

{\footnotesize\begin{verbatim}
r = engine->RegisterObjectMethod("EntityHandle", "bool IsValid() const",
  asMETHOD(EntityHandle, IsValid), asCALL_THISCALL); OC_SCRIPT_ASSERT();
\end{verbatim}}

\begin{table}[htbp]
	\centering
		{\scriptsize
		\begin{tabular}{|p{0.55\hsize}|p{0.38\hsize}|}
		\hline
		A macro declaration & An example\\
		\hline
		\verb/asFUNCTION(global_function_name)/ & \verb/asFUNCTION(Add)/\\
		\verb/asFUNCTIONPR(global_function_name, (parameters),/ \verb/  return_type)/ & \verb/asFUNCTIONPR(Add, (int), void)/\\
		\verb/asMETHOD(class_name, method_name)/ & \verb/asMETHOD(Object, Add)/\\
		\verb/asMETHODPR(class_name, method_name, (parameters),/ \verb/  return_type)/ & \verb/asMETHOD(Object, Add, (int), void)/\\
		\hline
		\end{tabular}
		}
	\caption{Used macros for a function and method registration}
	\label{tab:script-macros}
\end{table}

\begin{table}[htbp]
	\centering
		{\scriptsize
		\begin{tabular}{|p{0.24\hsize}|p{0.69\hsize}|}
		\hline
		A call convention & An use case\\
		\hline
		\verb/asCALL_CDECL/ & \verb/A cdecl function (for global functions)/\\
		\verb/asCALL_STDCALL/ & \verb/A stdcall function (for global functions)/\\
		\verb/asCALL_THISCALL / & \verb/A thiscall class method (for class methods)/\\
		\verb/asCALL_CDECL_OBJLAST / & \verb/A cdecl function with the object pointer as the last parameter/\\
		\verb/asCALL_CDECL_OBJFIRST / & \verb/A cdecl function with the object pointer as the first parameter/\\
		\hline
		\end{tabular}
		}
	\caption{Used calling conventions for a function and method registration}
	\label{tab:script-conventions}
\end{table}

Operators are registered as common methods but they have a special script declaration name such as \verb/opEquals/ or \verb/opAssign/. See AngelScript documentation \cite{angelscript} for further operator names.

If the class has some special constructors or destructor, they need to be registered by the \emph{RegisterObjectBehaviour} method which has same parameters as the \emph{RegisterObjectMethod} except an inserted second parameter that means which behavior is registered (see table \ref{tab:script-behaviors} for possible values). They must be registered by proxy functions that take a pointer to an object as the last argument (so the \verb/asFUNCTION/ macro and the \verb/asCALL_CDECL_OBJLAST/ calling convention are used) and fill it with a constructed object or call a correct destructor on it.

If the class is registered as a basic reference type, it needs to have a reference counter, a factory function and add-reference and release methods. These methods are registered by \emph{RegisterObjectBehaviour} method as well as constructor and destructor. The single-reference type does not need these methods but it cannot be passed as function parameter or stored to variable.

\begin{table}[htbp]
	\centering
		{\scriptsize
		\begin{tabular}{|p{0.63\hsize}|p{0.30\hsize}|}
		\hline
		A C++ function declaration & A behavior\\
		\hline
		\verb/void ObjectDefaultConstructor(Object* self)/ & \verb/asBEHAVE_CONSTRUCT/\\
		\verb/void ObjectCopyConstructor(Object& other, Object* self)/ & \verb/asBEHAVE_CONSTRUCT/\\
		\verb/void ObjectDestructor(Object* self)/ & \verb/asBEHAVE_DESTRUCT/\\
		\verb/Object *ObjectFactory()/ & \verb/asBEHAVE_FACTORY/\\
		\verb/void Object::Addref()/ & \verb/asBEHAVE_ADDREF/\\
		\verb/void Object::Release()/ & \verb/asBEHAVE_RELEASE/\\
		\hline
		\end{tabular}
		}
	\caption{Possible behaviors for the \emph{RegisterObjectBehaviour} method}
	\label{tab:script-behaviors}
\end{table}

It is also possible to register class properties by the \emph{RegisterObjectProperty} method but more portable is to register theirs getters and setters as class methods with strict declarations (\verb/type get_propname() const/ and \verb/void set_propname(type)/) so they can be used almost as registered directly (\verb/object.propname/).

Global functions are registered by the \emph{RegisterGlobalFunction} method that has almost same parameters as the \emph{RegisterObjectMethod} (does not have the first), global properties by \emph{RegisterGlobalProperty} method. There are also methods for registering enumerations (\emph{RegisterEnum}, \emph{RegisterEnumValue}) and typedefs for primitive types (\emph{RegisterTypedef}) that are easy to use. Further information about registering types can be found at the AngelScript documentation \cite{angelscript}, examples of using are in the \emph{ScriptRegister.cpp} file.

\subsection{Sample component}
\label{script-component}

As an example how to link the script and the entity system the Script component was created. The purpose of this component is to provide a possibility for an entity to respond to a received message by a script. When the message is received it should find an appropriate handler, which is a script function with a strict declaration (see EntityMessageTypes.h for an entity message handler declarations), in defined modules and call it with the arguments provided in the message data.

The component has five registered properties. The first one is an array of module names that are searched for message handlers, the second represents the maximum script execution time in milliseconds after that the script will be aborted. For better performance this component caches function IDs founded in modules in a map so it is necessary to inform it when the modules are going to change by sending a message \verb/RESOURCE_UPDATE/ to its entity.

The last three properties provides a support for scripts that should be called periodically and that should remember theirs state. These scripts are written to the \verb/void OnAction()/ message handlers which are called when the message \verb/CHECK_ACTION/ is received (which should be every game loop) and when the appropriate time in the \verb/Times/ property is lower than the current game time. From these scripts it is possible to call the \verb/int32 GetState()/ function which returns the appropriate state from the \verb/States/ property and to call the \verb/void SetAndSleep(int32, uint64)/ function which sets this state and sets the time to the current game time plus the second argument in milliseconds. The right time and state are got thanks to the \verb/CurrentArrayIndex/ property.

The most important method of this component is the \emph{Script::Handle\-Me\-ssa\-ge} that accept message structure as parameter and returns if the message was processed well or it was ignored. First it checks whether the function IDs should be updated and if the message is \verb/RESOURCE_UPDATE/ it ensures to do an update before the next message processing. Then it gets an appropriate function ID depended on a message type, checks whether to continue in case of the \verb/CHECK_ACTION/ message and calls the script manager to prepare a new context with this function. After that the pointer to the parent entity is stored to the context data so the \verb/GetCurrentEntityHandle/ function can be called from a script to get the current entity handle. Then it adds additional parameters to a function call from the message data according to the message type and executes the context with defined timeout. Finally it releases the context and returns whether the execution was successful.

\section{Glossary}

This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Value type] -- a primitive type (integer or real number, boolean value, enumeration or string) or an object that is copied on an assignment or a passing to or from a function
  \item[Reference type] -- an object that is assigned or passed to a function only through a pointer on it
  \item[Object handle] -- an equivalent of a reference in C++ that counts references on an object
	\item[Script class] -- a class defined and implemented in a script file, it is always used as a reference type
	\item[Script function] -- a function defined and implemented in a script file
	\item[Script file] -- one file containing script class and script function definitions, can include a code from other files
	\item[Script module] -- one or more script files connected with include directives, which are managed and builded together and have a common namespace
	\item[Function ID] -- an identification of a script function based on a module name and a function declaration
	\item[Script context] -- an object that wraps a script function calling, it must be prepared with a function ID, executed and released, function arguments can be passed and a return value can be obtained
	\item[Script engine] -- an object that registers C++ classes, global functions, properties etc. for use in a script code and manages script modules and contexts
	\item[Script manager] -- a class that encapsulated a script engine and provides methods for managing script modules and calling script functions
\end{description}

\begin{thebibliography}{9}                                                                                                
\bibitem {angelscript}AngelScript documentation, file /AngelScript/index.html

\end{thebibliography}