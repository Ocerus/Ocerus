\documentclass[a4paper, 12pt]{report}

\usepackage[USenglish]{babel}
\usepackage[T1]{fontenc}
\usepackage[ansinew]{inputenc}
\usepackage{lmodern} %Type1-font for non-english texts and characters
\usepackage{graphicx}

\newenvironment{titled-itemize}[1]
{
\vspace{5mm}
\noindent\emph{#1}
\begin{itemize}
}
{
\end{itemize}
}

\begin{document}

\pagestyle{empty} %No headings for the first pages.

\title{Design documentation of the Ocerus project}
\author{Lukas Hermann, Ondrej Mocny, Tomas Svoboda, Michal Cevora}
\maketitle

\pagestyle{plain} %Now display headings: headings / fancy / ...

\tableofcontents %Table of contents
\cleardoublepage %The first chapter should start on an odd page.

\chapter{Introduction}

\section{Purpose of this document}
%todo

\section{Project architecture}

The project Ocerus is logically divided into several relatively independent systems which cooperate with each other. Every system maintains its part of the application such as graphics, resources, scripts etc. and provides it to other ones. In the picture \ref{fig:system-connection} the relations among all systems are displayed with a brief description of what the systems provide to each other.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{SystemConnection.pdf}
	\caption{Dependencies among the systems}
	\label{fig:system-connection}
\end{figure}

The project has not been created from scratch but it is based on several libraries to allow the developers to focus on important features for the end users and top-level design rather than low-level programming. All used libraries support many platforms, have free licenses and have been heavily tested in a lot of other projects. All of them are used directly by one to three subsystems except the library for unit testing. The library dependences of each system are displayed in the picture \ref{fig:library-dependence}.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{LibraryDependence.pdf}
	\caption{Library dependencies of the project systems}
	\label{fig:library-dependence}
\end{figure}

In the table \ref{tab:library-list} a brief description of all used libraries is provided.

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			Library & Description\\
			\hline
			AngelScript\cite{angelscript} & a script engine with an own language\\
			Boost\cite{boost} & a package of helper data structures and algorithms\\
			Box2D\cite{box2d} & a library providing 2D real-time physics\\
			CEGUI\cite{cegui} & a graphic user interface engine\\
			DbgLib\cite{dbglib} & tools for a real-time debugging and crash dumps\\
			Expat\cite{expat} & a XML parser\\
			OIS\cite{ois} & a library for managing events from input devices\\
			OpenGL\cite{opengl} & an API for 2D and 3D graphics\\
			RTHProfiler\cite{rthprofiler} & an interactive real-time profiling of code\\
			RudeConfig\cite{rudeconfig} & a library for managing configure files\\
			SDL\cite{sdl} & a tool for an easier graphic rendering\\
			SOIL\cite{soil} & a library for loading textures of various formats\\
			UnitTest++\cite{unittest} & a framework for a unit testing\\
			\hline
		\end{tabular}
		%}
	\caption[Used libraries with the description]{Used libraries with the description}
	\label{tab:library-list}
\end{table}

Except these libraries some small pieces of a third party code were used that are listed in the table \ref{tab:code-list}.

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.28\hsize}|p{0.65\hsize}|}
			\hline
			Third party code & Description\\
			\hline
			Properties, RTTI\cite{gpg5} & a basic concept of entity properties and runtime type information\\
			Tree\cite{tree} & an STL-like container class for n-ary trees\\
			FreeList\cite{gpg5} & free lists / memory pooling implementation\\
			Pool allocator\cite{allocator} & pooled allocators for STL\\
			GLEW\cite{glew} & the OpenGL extension wrangler library\\
			OBJ loader\cite{objloader} & the Wavefront OBJ file loader\\
			PlusCallback\cite{pluscallback} & an easy use of function and method callbacks\\
			Script builder, script string\cite{angelscript} & an implementation of strings in the script engine and building more files to a script module\\
			\hline
		\end{tabular}
		%}
	\caption[Third party code with the description]{Third party code with the description}
	\label{tab:code-list}
\end{table}

In the following chapters each of the project systems will be described from the design view. At the beginning of each chapter there are a UML class diagram
%todo explanation of stereotypes
and a section about a purpose of the described system and at the end of most chapters there is a small glossary of terms used in that chapter.


\chapter{Core}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{CoreClassDiagram.pdf}
	\caption{Class diagram of the Core namespace}
	\label{fig:core-diagram}
\end{figure}

\section{Purpose of the core}

The Core namespace is the main part of the whole system. It contains its entry point and other classes closely related to the application itself. Its main task is to initialize and configure other engine systems, invoke their update and draw methods in the main loop and in the end correctly finalize them.

In the following sections the class representing the application as well as the classes corresponding to the application states (loading screen, game), configuration and project management will be introduced. In the last section there is a small glossary of used terms.

\section{Application}

When the program starts it creates an instance of the class \emph{Core::Application}, initializes it by calling its method \emph{Init} and calls the \emph{RunMainLoop} method which runs until the application is shutdown, then the instance is deleted and the program finishes (see figure \ref{fig:application-states}).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ApplicationStates.pdf}
	\caption{Possible states of the Application class}
	\label{fig:application-states}
\end{figure}

On the initialization of the application the configuration is read (see section \ref{sec:config}) and all engine systems are created and initialized as well as the loading screen and game classes. The state of application is changed to \emph{loading} and the main loop is running until the state is changed to \emph{shutdown}. At the main loop window messages are processed, performance statistic are updated and other engine systems including the game class are loaded (in the \emph{loading} state) or updated and drawn (in the \emph{game} state).

In the application class there are also methods for getting an average and last FPS statistic, methods for showing and hiding a debug console as well as writing message to it or a method for executing an external file. There are also the variables indicating whether the current application instance includes the editor (in a game distribution the editor should be disabled) and whether the editor is currently turned on so the game is running only in a small window instead of a full screen mode. From this class it is possible to get the current project as well as deploy it to the specific platform and destination.

\section{Game}

The \emph{Core::Game} class manages the most important stuff needed to run the game such as drawing a scene, updating physics and logic of entities, measuring time, handling a game action or resolving an user interaction. Of course it mostly delegates this work to other parts of the engine (see table \ref{tab:game-relation}).

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.18\hsize}|p{0.75\hsize}|}
			\hline
			Design entity & Relation to the Game class\\
			\hline
			\multicolumn{2}{|c|}{Game is affected by}\\
			\hline
			Application & initializes, updates, destroys it\\
			Editor & sets render target, can delegate input\\
			InputMgr & can delegate input\\
			ResourceMgr & loads the saved game\\
			\hline
			\multicolumn{2}{|c|}{Game affects what}\\
			\hline
			GfxRenderer & invokes drawing entities\\
			Physics & initializes, updates and destroys it, processes its events\\
			EntityMgr & broadcasts update and draw messages to entities\\
			ScriptMgr & gives the game time\\
			GUIMgr & stores the root window for the game GUI\\
			\hline
		\end{tabular}
		%}
	\caption[Relations of the Game class]{Relations of the Game class}
	\label{tab:game-relation}
\end{table}


Before the game initialization at the method \emph{Init} a valid render target (a camera and a viewport, see section \ref{sec:render-target}) must be set by the method \emph{SetRenderTarget} or the default one must be created by the method \emph{CreateDefaultRenderTarget} to know where to draw the game content. This is done by the \emph{Core::Project} class when a scene is being opened and it can delegate it to the editor if it is available. Then physics, time, an action etc. are initialized and in the \emph{Update} method called in the main loop they are updated.

The drawing of a scene is invoked in the method \emph{Draw}. The render target is cleared, all entities in the current scene are drawn by a renderer and the rendering is finalized.

There are several methods for handling a game action which can be in two states -- paused or running. When the action is running physics and logic of entities are updated in the method \emph{Update} which means the corresponding messages are broadcast to all entities before and after the update of the physical engine. The action can be paused, resumed and restarted to previously saved position. There is a global timer that measures game time (can be obtain by the method \emph{GetTimeMillis}) when the game is running which is used by other systems such as the script system.

Since the class \emph{Core::Game} registers the input listener to itself there are callbacks where it is possible to react to keyboard and mouse events such as a key or mouse button press/release or a mouse move. The corresponding information such as a current mouse position is available through the callback parameters.

If it is necessary to store some extra information that is shared among the game scenes (i.e. total score) the dynamic properties of this class should be used. There are template methods for getting or setting any kind of value under its name as well as methods for deleting one or all properties and for loading and saving them from/to a file. The properties are now stored along with other game stuff.
%todo add reference to dynamic properties explanation

\section{Loading screen}

The \emph{Core::LoadingScreen} class loads resource groups into the memory and displays information about the loading progress. It is connected to the resource manager that calls its listener methods when a resource or a whole resource group is going to be loaded or has been already loaded so it can update progress information.

First it is necessary to create an instance of the \emph{Core::LoadingScreen} class. The only method of this class that should be called explicitly is the \emph{DoLoading} one. The first parameter represents the kind of data to be loaded. Basic resources containing necessary pictures for a loading screen must be loaded first, then general resources needed in most of the states of the application should be loaded. If the editor should be available its resources must be in the memory too. The last usage of this method is the loading of scenes where the second parameter (a name of a scene) must be filled.

The \emph{DoLoading} method invokes the resource manager for loading corresponding resources and the manager calls callback methods informing about the state of loading. For each resource group the \emph{ResourceGroupLoadStarted} method is called first with the group name and a count of resources in the group. Then for each resource in the group the \emph{ResourceLoadStarted} method with a pointer to the resource class is called before the loading starts and the \emph{ResourceLoadEnded} method is called after the loading ends. Finally when a whole resource group is loaded the \emph{ResourceGroupLoadEnded} is called. Each of these methods calls the \emph{Draw} method that shows the loading progress to the user.

In the present implementation the loading progress is shown as a ring divided to eight parts that one of them is drawn brighter than the others. Once a while the next part (in a clockwise order) is selected as a brighter one. Since this implementation shows only that something is loading but not the real progress it can be changed if it is necessary.

\section{Configuration}
\label{sec:config}

The \emph{Core::Config} class allows storing a configuration data needed by various parts of the program. It serves as a proxy class between the engine and the RudeConfig library\cite{rudeconfig}. Supported data types are strings, integers and booleans and they are indexed by text keys and they can be grouped to named sections.

This class is initialized by a name of the file where data are or will be stored. Although changes to a configuration are saved when the class is being destructed it is possible to force it and get the result of this action by the method \emph{Save}.

There are several getter and setter methods for each data type that get or set data according to a key and a section name. A section parameter is optional, the section named \verb|General| is used as a default. The getter methods have also a default value parameter that is returned when a specific key and section do not exist in a configuration file. It is possible to get all keys in a specific section to a vector with the method \emph{GetSectionKeys} or remove one key (\emph{RemoveKey}) or a whole section (\emph{RemoveSection}).

\section{Project}

The \emph{Core::Project} class manages the project and its scenes both in the editor and in the game. There are methods for creating and opening a project in a specific path as well as closing it and getting or setting project information (a name, a version, an author). Other methods of this class manage scenes of the project -- creating, opening, saving, closing etc. Some methods like creating or saving scenes can be called only in the editor mode and are not accessible from scripts.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Loading screen] -- a screen visible during a loading of the game indicating a loading progress
  \item[Main loop] -- a code where an input from user is handled, an application logic is updated and a scene is drawn in a cycle until an application shut down
  \item[FPS] -- a count of frames per second that are drawn indicates a performance of a game
  \item[Render target] -- a region in an application window where a game content is drawn to
  \item[Resource] -- any kind of data that an application needs for its running (i.e. pictures, scripts, texts etc.)
  \item[Configuration data] -- data that parameterizes the application running (i.e. a screen resolution, a game language etc.)
  \item[Project] -- represents one game created in the editor that can be run independently, it is divided to scenes
  \item[Scene] -- represents one part of the game that is loaded at once (i.e. a game level, a game menu etc.)
\end{description}



\chapter{Gfx system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{GfxSystemClassDiagram.pdf}
	\caption{Class diagram of the GfxSystem namespace}
	\label{fig:gfxsystem-diagram}
\end{figure}

\section{Purpose of the graphic system}

The graphic system implements functionalities related to the rendering of game entities and the management of the application window. The design of this system is influenced by the requirement of platform independence. Note that the GUI system uses its own rendering system.

In the following sections the concept of viewports and render targets will be described as well as the process of rendering game entities, the way of creating the application window will be revealed and the management of meshes and textures will be introduced. In the last section there is a small glossary of used terms.

\section{Graphic viewport and render target}
\label{sec:render-target}

The \emph{GfxSystem::GfxViewport} class defines a place where all game entities will be rendered. It simply stores the information about a position and a size within the global window, that can be obtained from some texture, and also the data needed for drawing a grid, which is useful in the edit mode. It has methods for getting and setting these properties as well as other ones for calculating its boundaries in the world or scene space.

For drawing the game entities it is also necessary to know from which position and where they are rendered, so the \emph{GfxSystem::RenderTarget} type is defined which is a pair of a viewport and an entity handle that must point to an entity with a camera component. This type is used by renderer classes described below where it is indexed by the \emph{GfxSystem::RenderTargetID} type defined as an integer.

For easy moving and zooming a camera by a mouse in a render target the \emph{GfxSystem::DragDropCameraMover} class was defined. In its constructor or later by its setters it is possible to adjust a zoom sensitivity and a maximal and minimal allowed zoom.

\section{Renderer and scene manager}

The \emph{GfxSystem::GfxRenderer} is the main class that manages a rendering of entities to render targets. This is a platform independent abstract class handling a communication with other engine systems from which now derives only the \emph{GfxSystem::OglRenderer} class implementing a low level rendering in the OpenGL library\cite{opengl}. If it is necessary to implement a rendering for another library (i.e. DirectX) it should be done by deriving another class and implementing all abstract methods.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{RenderingActivityDiagram.pdf}
	\caption{Activity diagram of the rendering process}
	\label{fig:rendering-diagram}
\end{figure}

The abstract class has methods for managing its render targets, for drawing simple shapes as well as textures and meshes or for clearing the screen. As the diagram \ref{fig:rendering-diagram} shows, the rendering must be started by the \emph{GfxRenderer::BeginRendering} method, and then the current render target must be set and cleared. After everything is drawn the \emph{GfxRenderer\-::Finalize\-Render\-Target} method must be called and then another render target is set or the whole rendering is finished by the \emph{GfxRenderer::EndRendering} method.

An important attribute of the \emph{GfxSystem::GfxRenderer} class is the point\-er to the \emph{GfxSystem::SceneMgr} class created on its initialization accessible by the \emph{GfxRenderer::GetSceneManager} method. This is the class to which all drawable components (sprites, models) must be registered along with a \emph{Transform} component of their entity by the \emph{SceneMgr::AddDrawable} method so then they are rendered by the \emph{SceneMgr::DrawVisibleDrawables} method if they are visible.

To provide debug drawing of physics entities the \emph{GfxSystem::PhysicsDraw} proxy class was defined and registered as an implementation of the \emph{b2\-Debug\-Draw} class from the Box2D library. All methods are redirected to corresponding methods in the \emph{GfxSystem::GfxRenderer} class.

\section{Application window}

The graphic system also manages creating and handling the application window which depends on the used operating system. This functionality is implemented by the \emph{GfxSystem::GfxWindow} class with the usage of the SDL library. This class has methods for getting and setting a window position, size and title or a visibility of a mouse cursor, toggling a fullscreen mode and handling system window events. It is also possible to register a screen listener represented by a class implementing the \emph{GfxSystem::IGfxWindowListener} interface. This class will be informed when the screen resolution is changed.

Note that the SDL library also provides features in low-level audio and input management but since audio is not yet implemented and input management is done by more specialized library, the only used SDL features used are window management and creating rendering context.

\section{Mesh and texture}

Meshes and textures are essential parts of the \emph{Model} and \emph{Sprite} components. They can be loaded via the \emph{GfxSystem::Mesh} and \emph{GfxSystem::Texture} classes that inherit from the \emph{ResourceSystem::Resource} class (for more information see chapter about the resource system).

On loading of a texture resource the \emph{GfxRenderer::LoadTexture} abstract method is called. For OpenGL implementation the SOIL library is used which is a tiny C library used for uploading textures into the OpenGL and which supports most of the common image formats.

For defining meshes the Wavefront OBJ file format \cite{obj} is used. Every texture used in the model definition is automatically loaded as a resource.
 
\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Viewport] -- a region of the application window where entities are rendered to
  \item[Render target] -- a pair or a viewport and a camera
  \item[Sprite] -- a component for showing an entity as an image (even animated or transparent)
  \item[Model] -- a component for showing an entity as a 3D-model
  \item[Texture] -- a bitmap image applied to a surface of a graphic object
  \item[Mesh] -- a collection of vertices, edges and faces that defines the shape of a polyhedral object
\end{description}



\chapter{Entity system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EntitySystemClassDiagram.pdf}
	\caption{Class diagram of the Entity system namespace}
	\label{fig:entitysystem-diagram}
\end{figure}

\section{Purpose of the entity system}

The entity system creates a common interface for a definition of all game objects such as a game environment, a player character, a camera etc. and their behavior such as a drawing on a screen, an interaction with other objects etc. The object creation is based on a composition of simple functionalities that can be reused in many of them. The advantage of this unified system is an easy creating and editing of new objects from the game editor or from scripts, the disadvantage is a slower access to the object properties and behavior. It cooperates with the other systems like the graphics one for displaying objects or the script one for an interaction from scripts.

In the following sections the system of components and entities will be described as well as picking entities and organizing them in layers. In the last section there is a small glossary of used terms.

\section{Components and their manager}

Every game object is represented by an entity which is a compound of components that provide it various functionalities. A component can have several properties (and functions) which can be read or written (called) via their getters and setters (or functions themselves) and which are accessible through their unique name. It can also react to sent messages such as an initialization, a drawing, a logic update etc. by its own behavior. Component properties and behaviors are accessible only through an owner entity, so it is possible to read or write a specific property of an entity if it contains a component with this property and it is also possible to send a message to an entity which dispatches it to all its components that can react on it.

The \emph{EntitySystem::Component} class is a base class for all components used in the entity system. It inherits from the \emph{Reflection::RTTIBaseClass} class which provides the methods for working with RTTI (registering properties and functions of component, see section 
%todo \ref{utils-rtti}
).
It has methods for getting the owner entity, the component type (defined in ComponentEnums.h) and the component property from its name and for posting a message to the owner entity. It also introduces methods that should be overridden by specific components used for handling messages and the component creation and destruction (see the Extending Ocerus document).

The \emph{EntitySystem::ComponentMgr} is a singleton class that manages instances of all entity components in the entity system (see the figure \ref{fig:entity-component-managers-diagram}). Internally it stores mapping from all entities to lists of their components. It provides methods for adding a new component of a certain type to an entity and listing or deleting all or specific components from an entity. For passing all components of an entity the \emph{EntitySystem::EntityComponentsIterator} iterator is used that encapsulates a standard iterator (for example it has the \emph{HasMore} method which returns whether the iterator is at the end of the component list).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EntityAndComponentManagers.pdf}
	\caption{Objects managed by entity and component managers}
	\label{fig:entity-component-managers-diagram}
\end{figure}

\section{Entities and their manager}

An entity is represented by the \emph{EntitySystem::EntityHandle} class which sto\-res only an ID of the entity and provides methods that mostly calls corresponding methods of the entity manager with its ID. This class has also static methods that ensure all IDs in the system are unique.

For the creation of one entity the \emph{EntitySystem::EntityDescription} class is used that is basically a collection of component types. There are methods for adding a component type and setting a name and a prototype of the entity. It is also possible to set if the created object will be an instance or a prototype of an entity. Prototypes of entities are used to propagate changes of their shared properties to the instances that are linked to them so it is possible to change properties of many entities at once. Instances must have all components that has their prototype in the same order but they can also have own additional components that must be added after the compulsory ones.

It is possible to send messages to entities so there is the \emph{EntitySystem::EntityMessage} structure that represents them. It consists of the message type defined in EntityMessageTypes.h and the message parameters that are an instance of the \emph{Reflection::PropertyFunctionParameters} class. To add an parameter of any type defined in PropertyTypes.h the \emph{PushParameter} method can be called with a value as first argument or the \emph{operator}$<<$ can be used. There is also a method that checks whether the actual parameters are of the correct types according to the definition of message type (see section the Extending Ocerus document for more information).

All entities are managed by the \emph{EntitySystem::EntityMgr} class that stores necessary information about them in maps indexed by their ID (see the figure \ref{fig:entity-component-managers-diagram}). The most of its methods has the entity handle as the first parameter that means it applies on the entity of the ID got from the handle. There are methods for creating entities from an entity description, a prototype, another entity or an XML resource and for destroying them. Other methods manages entity prototypes -- it is possible to link/unlink an instance to/from a prototype, to set a property as (non)shared, to invoke an update of instances of a specific prototype and to create a prototype from a specific entity. Finally there are methods for getting entity properties even of a specific component (in case of two or more properties of a same name in different components), for registering and unregistering dynamic properties, for posting and broadcasting messages to entities and for adding, listing and removing components of a specific entity (see the figure \ref{fig:entity-communication-sequence} for implementation details).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EntityCommunicationSequence.pdf}
	\caption[The entity communication sequence diagram]{Process of getting an entity property and sending a message to an entity}
	\label{fig:entity-communication-sequence}
\end{figure}

\section{Entity picker}

The entity picker implemented by the \emph{EntitySystem::EntityPicker} class is a mechanism to select one or more entities based on their location. If the picker is used to select a single entity all it needs is a position in the world coordinates. The query then returns the found entity or none. This feature can be used to select the entity the mouse cursor is currently hovering over. The cursor position must be translated into the world coordinates via the rendering subsystem and its viewports. If the picker is used to select more entities a query rectangle (along with its angle) must be defined. This feature can be used to implement a multiselection using the mouse or gamepad. It is also possible to define two layers between which the picked entities must lie.

\section{Layer manager}

Every entity with the \emph{Transform} component has the layer property which is an ID of a layer from the layer manager implemented by the \emph{EntitySystem::LayerMgr} class. This class has many methods for creating, moving and destroying layers as well as getting and setting their names and visibility, entities in a specified layer and choosing the current active layer. There are also methods for loading and saving stored information from/to a file.

There is always one initial layer with the ID equal to 0 which cannot be deleted and other layers are either before (foreground, positive ID) or behind (background, negative ID) it.

\section{Glossary}

This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Entity property] -- a named pair of a getter and a setter function of a specific type with certain access rights
  \item[Entity function] -- a named link to a function with a \emph{Reflection::Property\-FunctionParameters} parameter and certain access rights
  \item[Entity message] -- a structure that stores a message type from EntityMessageTypes.h and message parameters
  \item[Component] -- a class which has registered functions and properties, that can be read and written via their getters and setters, and which can handle received messages
  \item[Entity] -- a compound of one or more components, that provide specific functionalities, represented by a unique ID, it is possible to post a message to it
  \item[Prototype] -- changes of shared property values of this entity are propagated to the linked entities
  \item[Entity picker] -- a mechanism to select one or more entities
  \item[Layer] -- a number which defines a z-coordinate of an entity in a scene
\end{description}


\chapter{GUI system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{GUISystemClassDiagram.pdf}
	\caption{Class diagram of the GUI system namespace}
	\label{fig:guisystem-diagram}
\end{figure}

\section{Purpose of the GUI system}

The GUI system provides creating and drawing a graphic user interface based on the CEGUI library for the editor and the game itself. It also manages a user interaction with GUI elements, element layouts, viewports and GUI console.

In the following sections the GUI manager and its resource and script providers will be described as well as concept of layouts, viewports, popup menus and the GUI console. In the last section there is a small glossary of used terms.

\section{GUI manager}

The main class of the GUI system is the \emph{GUISystem::GUIMgr} which is a connector for drawing, input handling and resource and script providing between the CEGUI library and the engine. During its creation it creates a CEGUI renderer, connects the resource manager with the CEGUI system via the \emph{GUISystem::Resource\-Provider} class (see section \ref{sec:gui-resources}), connects the script manager with the CEGUI system via the \emph{GUISystem::ScriptProvider} class (see section \ref{sec:gui-script}), provides itself as an input and screen listener and creates the GUI console which is then accessible via the \emph{GUIMgr::GetConsole} method (see section \ref{sec:gui-console}). On its initialization (\emph{GUIMgr::Init}) it loads necessary GUI resources (schemes, image sets, fonts, layouts and looknfeels) and creates a root window.

For loading a root layout from a file the method \emph{GUIMgr::LoadRootLayout} is provided with only one parameter specifying a name of a file where a layout is defined. This method calls the \emph{GUIMgr::LoadWindowLayout} which is a common method for loading a window layout from a file that also provides a translation of all texts via the string manager. There are also methods for unloading and getting the current root layout. For more information about layouts see section \ref{sec:gui-layouts}.

There are two methods called in the application main loop. First the \emph{GUIMgr::Update} updates time of the GUI system, and then the \emph{GUIMgr::\-Render\-GUI} draws the whole GUI. There are several input callback methods that converts an OIS library representation of keyboard and mouse events to a CEGUI one and forwards them to the CEGUI library. It is possible to get the currently processing input event by the \emph{GUIMgr::GetCurrentInputEvent} method. There is also a callback method for a resolution change that forwards this information to the CEGUI library too.

\section{GUI resources}
\label{sec:gui-resources}

A GUI resource is represented by the \emph{GUISystem::CEGUIResource} class. Since the CEGUI library is not designed to allow an automatic resource unloading and reloading on demand this class only loads raw data by the resource manager and after providing them to the CEGUI library by the \emph{CEGUIResource::GetResource} method it unloads them.

When the CEGUI library needs a resource it calls an appropriate method of a resource provider class provided on an initialization of the library. In this engine it is the \emph{GUISystem::ResourceProvider} class and its method \emph{ResourceProvider::loadRawDataContainer} that gets the resource from the resource manager and forwards its data to the library. In the figure \ref{fig:load-layout-sequence} there is an example of loading a GUI layout of the \emph{GUISystem::MessageBox} class.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{LoadLayoutSequence.pdf}
	\caption{An example of loading a GUI layout}
	\label{fig:load-layout-sequence}
\end{figure}

\section{Script provider}
\label{sec:gui-script}

For a connection of the CEGUI library and the script system the \emph{GUISystem::ScriptProvider} class is introduced implementing the \emph{CEGUI::Script\-Module} interface. The only method from this interface which truly needs an implementation is the \emph{ScriptModule::subscribeEvent} which provides a name of event, a name of function that should handle it and an object to which the name of event and an object with a callback method should be subscribed.

This transformation is implemented by the \emph{GUISystem::ScriptCallback} class which stores the function name given in its constructor and which calls an appropriate script function as a callback. It calls a function from the script module associated with the GUI layout component of the layout which gets the event or a function from the \verb/GuiCallback.as/ module as a default. For more information see the User Guide document.
%todo the User Guide document???

\section{Layouts}
\label{sec:gui-layouts}

A GUI layout defines a composition of GUI elements including their properties such as position, size and content and their behavior. Their properties can be defined in an external XML file but more dynamic compositions need also a lot of a code support, their behavior can be defined in an external script file but more complicated reactions have to be also native coded.

As an example that can be used both in the editor and in the game the \emph{GUISystem::MessageBox} class was created which provides a modal dialog for informing the user or for asking the user a question and receiving the answer. The basic layout with all possible buttons is specified in an XML file which is loaded in a class constructor where these buttons are mapped to the correspondent objects and displayed according to a message box type. Setting of a message text (\emph{MessageBox::SetText}) also changes a static text GUI element specified in an XML file. The behavior after the user clicks to one of buttons is defined by a callback function that can be registered by the \emph{MessageBox::RegisterCallback} method and that gets the kind of the chosen button and the ID specified in a constructor parameter. For an easier usage there is the global function \emph{GUISystem::ShowMessageBox} that takes all necessary parameters (a text, a kind of a message box, a callback and an ID) and creates and shows an appropriate message box. A similar concept has the \emph{GUISystem::PromptBox} class providing a modal dialog that asks for a text input from the user and the \emph{GUISystem::FolderSelector} class providing a modal dialog for selecting a folder.

Another example is the \emph{GUISystem::VerticalLayout} class that helps to keep GUI elements positioned in a vertical layout and automatically repositions them when one of them changes its size. In its constructor the container in which all child elements should be managed is specified, and then the \emph{VerticalLayout::AddChildWindow} method is used for adding them. It is also possible to set spacing between them and there is a method for updating a layout. It is obvious that this layout is defined without any XML file. For more information about creating own layouts see the User Guide document.
%todo the User Guide document???

\section{Viewports}

The \emph{GUISystem::ViewportWindow} class represents a viewport window with a frame where a scene is rendered by the graphic system. For defining a position, an angle and a zoom of a view of a scene which will be displayed in the viewport a camera in form of an entity with a camera component must be set by the \emph{ViewportWindow::SetCamera} method. It is possible to define whether the viewport allows a direct edit of a view and displayed entities by the \emph{ViewportWindow::SetMovableContent} method. For example in the editor there are two viewports -- in the bottom one the scene can be edited whereas in the top one the result is only shown. The method \emph{ViewportWindow::AddInputListener} registers the input listener so any class can react to mouse and keyboard actions done in the viewport when it has been activated by the method \emph{ViewportWindow::Activate}.

\section{Popup menus}

The \emph{GUISystem::PopupMgr} class provides methods creating (\emph{Popup\-Mgr\-::\-Create\-Popup\-Menu} / \emph{PopupMgr::CreateMenuItem}) and destroying (\emph{PopupMgr::DestroyPopupMenu} / \emph{PopupMgr::DestroyMenuItem}) popup menu and its items as well as showing (\emph{PopupMgr::ShowPopup}) and hiding (\emph{PopupMgr::HidePopup}) it and it also cares about calling a proper callback when a menu item is clicked on. The callback method is provided to the manager when the popup menu is being opened by the \emph{PopupMgr::ShowPopup} method.

\section{GUI console}
\label{sec:gui-console}

The \emph{GUISystem::GUIConsole} class manages the console accessible both in the game and in the editor. The console receives all messages from the log system via the method \emph{GUIConsole::AppendLogMessage} and shows those ones which have an equal or higher level than previously set by the \emph{GUIConsole::SetLogLevelTreshold} method. In addition the user can type commands to the console prompt line which are sent to the script system as a body of a method without parameters that is immediately built and run and if there is a call of the \verb/Print/ function its content will be printed to the console via the \emph{GUIConsole::AppendScriptMessage} method. For better usage of the console a history of previously typed commands is stored and can be revealed by up and down arrows. The console can be shown or hide by \emph{GUIConsole::ToggleConsole} method.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[GUI] -- a graphic user interface
  \item[GUI element] -- an element from which the whole GUI is created such as label, edit box, list etc.
  \item[Layout] -- a composition of GUI elements including definition of their properties and behavior
  \item[Viewport] -- a GUI element where a scene can be rendered by the graphic system
  \item[GUI console] -- a window where log and script messages immediately appears and which allows an input of script commands
  \item[GUI event] -- a significant situation made by the user input such as a mouse click or a keyboard press
  \item[Callback] -- a function or method that is called as a reaction to a GUI event
  \item[Scheme] -- a definition of connections between a physical window type and a window look
\end{description}

\chapter{Editor}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EditorClassDiagram.pdf}
	\caption{Class diagram of the Editor namespace}
	\label{fig:editor-diagram}
\end{figure}

\section{Purpose of the editor}

The editor is used for an easy creation of a new game based on this engine. It provides a well-arranged graphic user interface for managing everything from the whole project to each entity in several scenes. The main advantage is that every change made to a scene is immediately visible in the game window where the game action can be started anytime.

In the following sections the classes providing the editor will be described. They do not have to be contained in the final distribution of the game if an editor support should not be allowed. First section is focused on the logical and graphical managers of the editor whereas the second section is about layouts used to build the GUI of the editor. In the last section a concept of value editors is introduced.

\section{Editor managers}

The \emph{Editor::EditorMgr} class manages the logical part of the editor and it owns an instance of the \emph{Editor::EditorGUI} class that focuses to the GUI of the editor. Both of them have methods called at the loading and the unloading of the editor and also methods for updating logic and drawing in the application loop.

The first mentioned class has methods for managing projects, scene and entities. It manages selecting entities and editing the current one, it reacts on choosing all items in the main menu such as creating a new entity, duplicating and deleting current or selected entities, adding and removing entity components, creating a prototype from a current entity, creating or loading a project or a scene and it solves changing an entity name or an entity property. It also provides a function for all edit tools such as moving, rotating or scaling of a chosen entity and for resuming, pausing and restarting the game action. Finally there are methods for getting reference to all editor windows and for updating them.

The second class compounds all editor layouts such as the game and editor viewports, the resource, prototype and layer windows and the editor menu and initializes and updates them. It directly updates the entity editor window according to the current entity that uses the vertical layout for positioning entity components and various value editors for showing and editing all kinds of entity properties such as strings, vectors, resources and arrays.

\section{Used layouts}

There are six layout classes for editor components. All of them have initialization and update methods and callbacks for significant events and load their look from an external XML file and introduce the reactions on events and loading data from the application. The \emph{Editor::Create\-Project\-Dialog} represents the dialog for creating a new project, the \emph{Editor\-::\-Hierarchy\-Window} manages the hierarchy of entities, the \emph{Editor\-::\-Layer\-Window} manages the layers the entities are put to, the \emph{Editor\-::\-Prototype\-Window} manages the prototypes of entities, the \emph{Editor\-::\-Entity\-Window} manages components and properties of entities and the \emph{Editor\-::\-Resource\-Window} manages the resources that the entities can use.

\section{Value editors}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.8\textwidth]{EditorValueEditorsClassDiagram.pdf}
	\caption{Class diagram of editor value editors}
	\label{fig:editor-value-editors-diagram}
\end{figure}

All value editors derive from the \emph{Editor::AbstractValueEditor} base class. This class has three abstract methods that every value editor must implement and some methods that can help with the implementation. The first is the \emph{AbstractValueEditor::CreateWidget} method with the parameter representing a string that should be used as a prefix for a name of every created component. This method should create a widget for editing a required kind of value and return it. The second is the \emph{AbstractValueEditor::Update} method which is called when the current value of the property should be displayed in the value editor and the last is the \emph{AbstractValueEditor::Submit} method which is called when the value of the property should be updated by the user input to the value editor.

For an easier implementation of value editors the model classes with the \emph{Editor::IValueEditorModel} class as the base class were created. From the accessors of this class value editors should get the name and tool-tip for the edited property, whether the property is valid, read only, an element of a list, removable, shareable, shared and also they should be able to remove the property or set whether it is shared if is possible. It is recommended to derive own models from the \emph{Editor::ITypedValueEditor\-Model$<$T$>$} template class that also defines the getter and setter for the value of the edited property.

For example the \emph{Editor::StringEditor} class derives directly from the \emph{Editor::AbstractValueEditor} class and implements a simple editor for properties which values are easily convertible from and to string which contains a label with a property name, an edit box for displaying and editing the value and a remove button if the property is removable (i.e. as a part of an array). It uses a model derived from the \emph{Editor::ITypedValueEditorModel$<$string$>$} class to create a widget, update and submit the value which is specified in the constructor parameter. A useful implementation of this model is the \emph{Editor::StringPropertyModel} class that operates with the \emph{Reflection::Property\-Holder} class from which it gets all necessary information and which it can modify with a new value.

There are another examples of value editors and its models in the code that can help with a creation of further ones such as editors for arrays, resources etc.

\chapter{Input system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{InputSystemClassDiagram.pdf}
	\caption{Class diagram of the Input system namespace}
	\label{fig:inputsystem-diagram}
\end{figure}

\section{Purpose of the input system}

Since each game must somehow react to the input from the player, the input system was implemented which handles keyboard and mouse events and forwards them to other systems.

In the following section the way of receiving and distributing input events is described.

\section{Input manager}
The needs of games are different, but the ways they want to access the input devices are still the same. Either they want to receive a notification when something interesting happens or they want to poll the device for its current state. The \emph{InputSystem::InputMgr} class implements both of the approaches.

The first one is provided via the \emph{InputSystem::IInputListener} interface which should be implemented and then registered by using the \emph{InputMgr::\-AddInputListener} method for receiving the notification in callbacks of the interface.

The second approach is supported by multiple methods for querying the device state. The \emph{InputMgr::IsKeyDown} method returns whether any specific key is currently held down while the \emph{InputMgr::IsMouseButtonPressed} method does the same with the currently pressed mouse button. Finally the \emph{InputMgr::GetMouseState} returns a whole bunch of mouse related information such as a cursor and wheel position or pressed buttons.

To keep things synchronized the event processing is executed in the main game thread. At the beginning of the application main loop the \emph{InputMgr::CaptureInput} method is called where the events are recognized and then distributed to the listeners.

The \emph{InputSystem::InputMgr} class is only a proxy class which calls methods of the implementation specific class \emph{InputSystem::OISListener} which implements the \emph{OIS::MouseListener} and \emph{OIS::KeyListener} interfaces from the OIS library used for the platform independent input management.


\chapter{Log system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{LogSystemClassDiagram.pdf}
	\caption{Class diagram of the Log system namespace}
	\label{fig:logsystem-diagram}
\end{figure}

\section{Purpose of the log system}

The log system manages internal log messages that are used to provide information about application processes useful to debug the whole project. These messages can have various levels of a severity (from trace and debug messages to errors) and it is possible to set the minimal level of messages to show (i.e. only warning and errors). Another function of the log system is managing a real-time in-game profiling useful for a location of the most time critical parts of the project which can leads to effective optimization.

In the following sections the process of logging messages will be described as well as using a profiler. In the last section there is a small glossary of used terms.

\section{Logging messages}
\label{sec:logging}

The main class responsible for logging messages is the \emph{LogSystem::LogMgr}. At the application start it is initialized with a name of the file to which the messages are also written. There is only one method which logs a message of a certain severity to the file and consoles if exist. This method should not be used directly but via the class \emph{LogSystem::Logger}.

The lifetime of the \emph{Logger} should be only one code statement and it represents one message. In the constructor a level of the message and whether to generate a stack trace are specified. Then a sequence of the operator $<<$ is used to build the message from strings, numbers and other common types (any user type can be supported by specifying an own operator $<<$ overloading). At the end of the statement the destructor is automatically called (if the instance is not assigned to a variable) that called the \emph{LogMgr}'s method with the built message.

For an even easier logging of messages log macros are defined for every supported level of severity, adding the information about the file and the line where it is logged from in case of error or warning message. Thanks to macros it is possible to define the minimum level of severity that should be logged at the compile time so the messages with a lower level are even not compiled to the final program which saves time and memory. In the table \ref{tab:log-macros} there are the macros associated with the levels of severity.

\begin{table}[htbp]
	\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			Macro & Level & Stack trace & Additional info \\
			\hline
			ocError & error & yes & yes \\
			ocWarning & warning & no & yes \\
			ocInfo & information & no & no \\
			ocDebug & debug & no & no \\
			ocTrace & trace & no & no \\
			\hline
		\end{tabular}
	\caption[Definitions of log macros]{Definitions of log macros from the most severe to the least ones}
	\label{tab:log-macros}
\end{table}

If it is for example necessary to inform that the entity (of which the handle is available) is created the following statement should be written anywhere in the code: \verb/ocInfo << handle << " was created.";/. When the process passed this code and the minimum level of messages to log is lower than the information one then for example the following message will be generated: \verb/13:05:18: Entity(25) was created./

\section{Profiling functions}
\label{sec:profiling}

The profiling of a block of a code or a whole function is really easy. First the \verb/USE_PROFILER/ preprocessor directive must be globally defined, the class \emph{LogSystem::Profiler} must be initialized at the start of the application and its method \emph{Update} must be called in each application loop.

Then anywhere in a code the \verb/PROFILE(name)/ macro can be typed where the parameter \verb/name/ is used for identification of the corresponding results (the abbreviation \verb/PROFILE_FNC()/ uses the current function name). From that line the profiler will start measuring time and it will stop at the end of the current block or function.

Finally when the application runs a call of \emph{Profiler}'s method \emph{Start} (which can be invoked with a keyboard shortcut \emph{CTRL+F5}) activates a profiling and a call of its methods \emph{Stop} and \emph{DumpIntoConsole} (another press of \emph{CTRL+F5}) deactivates it and writes results to the text console. In addition it is possible to ask whether the profiler is active via the method \emph{IsRunning}.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Log message] -- a text describing a specific action or an application state occurred at a certain time with a defined severity
  \item[Level of severity] -- an importance of a message to the application process
  \item[Stack trace] -- a list of functions that the current statement is called from right now
  \item[Logging] -- tracking the code execution by writing log messages to a console and a file
  \item[Console] -- a window where log messages immediately appear
  \item[Profiling] -- measuring a real time of execution of a specific code
\end{description}



\chapter{Resource system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ResourceSystemClassDiagram.pdf}
	\caption{Class diagram of the Resource system namespace}
	\label{fig:resourcesystem-diagram}
\end{figure}

\section{Purpose of the resource manager}

Every game needs to load packs of data from external devices such as a hard drive or network. The data come in blocks belonging together and representing a unit of something usually called \emph{resource}. Since the games work with loads of resources it is necessary to organize them both in-game and on the disk. Also, the data loaded are usually quite large and it's necessary to free them when possible to save memory. All of these tasks are implemented in the resource system.

In the following sections the mapping of a resource to the engine will be described as well as the resource manager. Also a way of loading and saving scenes will be introduced. In the last section there is a small glossary of used terms.

\section{Resources}

The resource is a group of data belonging together. In the engine this is represented by the abstract \emph{ResourceSystem::Resource} class. It contains all basic attributes of a resource and allows its users to load or unload it, but the actual implementation depends on the specific type of the resource. For example, an XML file is loaded and parsed in a different way then an OpenGL texture. However, for the user it is never really necessary to know what type of the resource he is working with, so using this class as an abstraction is enough. Only the endpoint subsystem needs to work with the specific type to be able to grab the parsed data out of it. For example, the texture resource can be carried around the system as a common \emph{ResourceSystem::Resource} class until it reaches the graphical subsystem which converts it to the texture resource and grabs the implementation specific texture data out of it.

\subsection{Resource states}

Each resource can be in one of the states described in the figure \ref{fig:resource-states} at the given point of time:

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ResourceStates.pdf}
	\caption[Possible resource states]{Possible resource states and their description}
	\label{fig:resource-states}
\end{figure}

\subsection{Content of the resource}

Once the data for the resource are loaded it must be parsed into the desired format. This can mean a data structure stored directly inside the resource class or just a handle to the data stored in other parts of the system. However, both of these must exist only in single instance in the whole system -- in the resource which parsed the data. Otherwise the data could become desynchronized. If the resource was unloaded, a pointer to its data could still exist somewhere. 

For example, the XML resource creates a tree structure for the parsed data and allows its users to traverse the tree. But nowhere in the system a pointer to the same tree or any of its parts exists. Another example is a texture. After it loads data they are passed into the graphical subsystem which creates a platform specific texture out of it and returns only a texture handle. This handle is then stored only in the resource.

\subsection{Resource pointers}

Since the resources are passed all around the game system we must somehow prevent any memory leaks from appearing. Doing so is quite easy however -- we simply use the shared pointer mechanism. It points to the common abstract resource (the \emph{ResourceSystem::ResourcePtr} class) and to specific resources as well (the \emph{ScriptSystem::ScriptResourcePtr} or the \emph{ResourceSystem::XMLResourcePtr} classes for example). The abstract resource pointer can be automatically converted to any specific resource pointer, but if the type does not match an assertion fault will be raised to prevent a memory corruption. All resource pointers are defined in the \verb'Utils/ResourcePointers.h' file.

For defining a new resource type see the Extending Ocerus document. To see all currently existing types of resources it is best to locate the \emph{ResourceSystem::Resource} class and see all classes derived from it.

\section{Resource manager}

The resource manager represented by the \emph{ResourceSystem::ResourceMgr} class takes care of organizing resources into groups and providing an interface to other parts of the system to control or grab the resources. Coupling resources into groups makes it easier to load or unload a whole bunch of them. There are methods for adding one file or a whole directory to a resource group or for getting a resource pointer to a resource of a specific name from a specific group.

To make game development easier, the source of each resource is automatically checked for an update. If it has changed, the resource is automatically reloaded if it was previously loaded. So, for example, if the user changes a currently loaded texture in an image editor and saves it, it will be immediately updated in the game.

Since gaming systems have limited memory it is possible to limit the memory used by resources. Resources usually take the biggest chunk of memory, so when lowering the memory usage it is best to start here. Hopefully, the resource manager allows defining a limit which it will try to keep. When the memory is running out, it will attempt to unload resources which were not used for a long time. These resources will remain in the system and will be ready to be loaded as soon as they are needed. However, there are certain circumstances under which the resources must not be unloaded. An example of such is rendering -- no texture can be unloaded until the frame is ready. For this reason the unloading can be temporarily disabled.

If it is necessary to track the resource loading progress (for example when a scene is loading), there is the \emph{ResourceSystem::IResourceLoadingListener} interface that should be implemented and registered by the \emph{ResourceMgr\-::\-Set\-Loading\-Listener} method. Its methods are called when the loading of one resource or a resource group starts and ends.

\section{Loading and saving scenes}

For storing a state of a scene from the editor or from the game itself to a file an XML format is used. There are two classes that help with saving data to a file and loading them back.

The \emph{ResourceSystem::XMLOutput} class provides a formatted XML output to a file. First when the instance is created a file specified in a constructor parameter is opened. Then some methods for writing XML elements and attributes are used. Finally the file is closed in the destructor or in the method \emph{XMLOutput::CloseAndReport}. For example the file named \verb/file.xml/ with the XML structure

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<name key="value">
  <element>text</element>
</name>
\end{verbatim}

\noindent is created by calling this sequence of orders:

\begin{verbatim}
ResourceSystem::XMLOutput out("file.xml"); // writes header
out.BeginElementStart("name"); // writes <name
out.AddAttribute("key", "value"); // writes key="value"
out.BeginElementFinish(); // writes >
out.BeginElement("element"); // writes <element>
out.WriteString("text"); // writes text
out.EndElement(); // writes </element>
// destructor automatically closes all open elements
\end{verbatim}

\noindent As the example shows the class does an indent, remembers names of open elements and automatically closes all open elements in the end.

The \emph{ResourceSystem::XMLResource} class on the other hand loads an XML file and iterates over its elements and attributes. Since this class derives from the \emph{ResourceSystem::Resource} class first a resource pointer to the file must be get by \emph{ResourceMgr::GetResource} method and retyped to the \emph{ResourceSystem::XMLResourcePtr}. Then the top level elements can be iterated by \emph{XMLResource::IterateTopLevel} method which returns \emph{ResourceSystem::XMLNodeIterator} class which serves as an iterator and which should be compared with a result of the \emph{XMLResource::EndTopLevel} method for a detection of the end of top level elements. The iterator class has analogical methods (\emph{XMLNodeIterator::IterateChildren} and \emph{XMLNodeIterator::EndChildren}) for iteration over children of the element it represents. Beside them it has also methods for getting an element's value, a value of its child or of its specific attribute. Since these methods are templates every value can be converted from a string to any chosen data type.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Resource] -- a unit of data usually stored in an external device the game will be working with as a whole
  \item[Resource pointer] -- a shared pointer to a resource that can be used in the whole engine
  \item[Resource type] -- resources with a common type are loaded in the same way, i.e. textures, models, scripts, texts\ldots
  \item[XML] -- Extensible Markup Language (XML) is a set of rules for encoding documents in machine-readable form
\end{description}

%% A small distance to the other stuff in the table of contents (toc)
\addtocontents{toc}{\protect\vspace*{\baselineskip}}

%% The Bibliography 
\begin{thebibliography}{9}
\addcontentsline{toc}{chapter}{Bibliography} %'Bibliography' into toc
\bibitem {angelscript}AngelScript -- http://www.angelcode.com/angelscript
\bibitem {boost}Boost -- http://www.boost.org
\bibitem {box2d}Box2D -- http://www.box2d.org
\bibitem {cegui}CEGUI -- http://www.cegui.org.uk
\bibitem {dbglib}DbgLib -- http://dbg.sourceforge.net
\bibitem {expat}Expat -- http://expat.sourceforge.net
\bibitem {ois}OIS -- http://sourceforge.net/projects/wgois
\bibitem {opengl}OpenGL -- http://www.opengl.org
\bibitem {rthprofiler}Real-Time Hierarchical Profiling -- Greg Hjelstrom, Byon Garrabrant: Game Programming Gems 3, Charles River Media, 2002, ISBN: 1584502339
\bibitem {rudeconfig}RudeConfig -- http://rudeserver.com/config
\bibitem {sdl}SDL -- http://www.libsdl.org
\bibitem {soil}SOIL -- http://www.lonesock.net/soil.html
\bibitem {unittest}UnitTest++ -- http://unittest-cpp.sourceforge.net
\bibitem {gpg5}Kim Pallister: Game Programming Gems 5, Charles River Media, 2005, ISBN: 1584503521
\bibitem {tree}Kasper Peeters, http://www.aei.mpg.de/~peekas/tree
\bibitem {allocator}http://www.sjbrown.co.uk/2004/05/01/pooled-allocators-for-the-stl
\bibitem {glew}http://glew.sourceforge.net
\bibitem {objloader}http://www.dhpoware.com
\bibitem {pluscallback}http://codeplea.com/pluscallback
\bibitem {obj}Wavefront OBJ file structure -- http://en.wikipedia.org/wiki/Obj
\bibitem {cegui-doc}CEGUI documentation -- http://cegui.org.uk/api\_reference/index.html
\bibitem {angelscript-doc}AngelScript documentation -- file /AngelScript/index.html
\bibitem {ISO-639-1}ISO 639-1 -- http://en.wikipedia.org/wiki/List\_of\_ISO\_639-1\_codes
\bibitem {ISO-3166-1}ISO 3166-1 alpha-2 -- http://en.wikipedia.org/wiki/ISO\_3166-1\_alpha-2
\end{thebibliography}

%% The List of Figures
\clearpage
\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures

%% The List of Tables
\clearpage
\addcontentsline{toc}{chapter}{List of Tables}
\listoftables

\end{document}