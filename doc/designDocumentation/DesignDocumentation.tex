\documentclass[a4paper, 12pt]{report}

\usepackage[USenglish]{babel}
\usepackage[T1]{fontenc}
\usepackage[ansinew]{inputenc}
\usepackage{lmodern} %Type1-font for non-english texts and characters
\usepackage{graphicx}

\newenvironment{titled-itemize}[1]
{
\vspace{5mm}
\noindent\emph{#1}
\begin{itemize}
}
{
\end{itemize}
}

\begin{document}

\pagestyle{empty} %No headings for the first pages.

\title{Design documentation of the Ocerus project}
\author{Lukas Hermann, Ondrej Mocny, Tomas Svoboda, Michal Cevora}
\maketitle

\pagestyle{plain} %Now display headings: headings / fancy / ...

\tableofcontents %Table of contents
\cleardoublepage %The first chapter should start on an odd page.

\chapter{Introduction}

\section{Purpose of this document}
%todo

\section{Project architecture}

The project Ocerus is logically divided into several relatively independent systems which cooperate with each other. Every system maintains its part of the application such as graphics, resources, scripts etc. and provides it to other ones. In the picture \ref{fig:system-connection} the relations among all systems are displayed with a brief description of what the systems provide to each other.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{SystemConnection.pdf}
	\caption{Dependencies among the systems}
	\label{fig:system-connection}
\end{figure}

The project has not been created from scratch but it is based on several libraries to allow the developers to focus on important features for the end users and top-level design rather than low-level programming. All used libraries support many platforms, have free licenses and have been heavily tested in a lot of other projects. All of them are used directly by one to three subsystems except the library for unit testing. The library dependences of each system are displayed in the picture \ref{fig:library-dependence}.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{LibraryDependence.pdf}
	\caption{Library dependencies of the project systems}
	\label{fig:library-dependence}
\end{figure}

In this list a brief description of all used libraries is provided:

\begin{itemize}
  \item AngelScript\cite{angelscript} -- a script engine with an own language
  \item Boost\cite{boost} -- a package of helper data structures and algorithms
  \item Box2D\cite{box2d} -- a library providing 2D real-time physics
  \item CEGUI\cite{cegui} -- a graphic user interface engine
  \item DbgLib\cite{dbglib} -- tools for a real-time debugging and crash dumps
  \item Expat\cite{expat} -- a XML parser
  \item OIS\cite{ois} -- a library for managing events from input devices
  \item OpenGL\cite{opengl} -- an API for 2D and 3D graphics
  \item RTHProfiler\cite{rthprofiler} -- an interactive real-time profiling of code
  \item RudeConfig\cite{rudeconfig} -- a library for managing configure files
  \item SDL\cite{sdl} -- a tool for an easier graphic rendering
  \item SOIL\cite{soil} -- a library for loading textures of various formats
  \item UnitTest++\cite{unittest} -- a framework for a unit testing
\end{itemize}

Except these libraries some small pieces of a third party code were used:

\begin{itemize}
  \item Properties and RTTI\cite{gpg5} -- a basic concept of entity properties and runtime type information
  \item Tree\cite{tree} -- an STL-like container class for n-ary trees
  \item FreeList\cite{gpg5} -- free lists / memory pooling implementation
  \item STL pool allocator\cite{allocator} -- pooled allocators for STL
  \item GLEW\cite{glew} -- the OpenGL extension wrangler library
  \item OBJ loader\cite{objloader} -- the Wavefront OBJ file loader
  \item PlusCallback\cite{pluscallback} -- an easy use of function and method callbacks
  \item Script builder and script string\cite{angelscript} -- an implementation of strings in the script engine and building more files to a script module
\end{itemize}

In the following chapters each of the project systems will be described from the design view. At the beginning of each chapter there are a UML class diagram
%todo explanation of stereotypes
and a section about a purpose of the described system and at the end of most chapters there is a small glossary of terms used in that chapter.


\chapter{Core}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{CoreClassDiagram.pdf}
	\caption{Class diagram of the Core namespace}
	\label{fig:core-diagram}
\end{figure}

\section{Purpose of the core}

The Core namespace is the main part of the whole system. It contains its entry point and other classes closely related to the application itself. Its main task is to initialize and configure other engine systems, invoke their update and draw methods in the main loop and in the end correctly finalize them.

In the following sections the class representing the application as well as the classes corresponding to the application states (loading screen, game), configuration and project management will be introduced. In the last section there is a small glossary of used terms.

\section{Application}

When the program starts it creates an instance of the class \emph{Core::Application}, initializes it by calling its method \emph{Init} and calls the \emph{RunMainLoop} method which runs until the application is shutdown, then the instance is deleted and the program finishes (see figure \ref{fig:application-states}).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ApplicationStates.pdf}
	\caption{Possible states of the Application class}
	\label{fig:application-states}
\end{figure}

On the initialization of the application the configuration is read (see section \ref{sec:config}) and all engine systems are created and initialized as well as the loading screen and game classes. The state of application is changed to \emph{loading} and the main loop is running until the state is changed to \emph{shutdown}. At the main loop window messages are processed, performance statistic are updated and other engine systems including the game class are loaded (in the \emph{loading} state) or updated and drawn (in the \emph{game} state).

In the application class there are also methods for getting an average and last FPS statistic, methods for showing and hiding a debug console as well as writing message to it or a method for executing an external file. There are also the variables indicating whether the current application instance includes the editor (in a game distribution the editor should be disabled) and whether the editor is currently turned on so the game is running only in a small window instead of a full screen mode. From this class it is possible to get the current project as well as deploy it to the specific platform and destination.

\section{Game}

The \emph{Core::Game} class manages the most important stuff needed to run the game such as drawing a scene, updating physics and logic of entities, measuring time, handling a game action or resolving an user interaction. Of course it mostly delegates this work to other parts of the engine (see table \ref{tab:game-relation}).

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.18\hsize}|p{0.75\hsize}|}
			\hline
			Design entity & Relation to the Game class\\
			\hline
			\multicolumn{2}{|c|}{Game is affected by}\\
			\hline
			Application & initializes, updates, destroys it\\
			Editor & sets render target, can delegate input\\
			InputMgr & can delegate input\\
			ResourceMgr & loads the saved game\\
			\hline
			\multicolumn{2}{|c|}{Game affects what}\\
			\hline
			GfxRenderer & invokes drawing entities\\
			Physics & initializes, updates and destroys it, processes its events\\
			EntityMgr & broadcasts update and draw messages to entities\\
			ScriptMgr & gives the game time\\
			GUIMgr & stores the root window for the game GUI\\
			\hline
		\end{tabular}
		%}
	\caption[Relations of the Game class]{Relations of the Game class}
	\label{tab:game-relation}
\end{table}


Before the game initialization at the method \emph{Init} a valid render target (a camera and a viewport, see section \ref{sec:render-target}) must be set by the method \emph{SetRenderTarget} or the default one must be created by the method \emph{CreateDefaultRenderTarget} to know where to draw the game content. This is done by the \emph{Core::Project} class when a scene is being opened and it can delegate it to the editor if it is available. Then physics, time, an action etc. are initialized and in the \emph{Update} method called in the main loop they are updated.

The drawing of a scene is invoked in the method \emph{Draw}. The render target is cleared, all entities in the current scene are drawn by a renderer and the rendering is finalized.

There are several methods for handling a game action. The action can be paused, resumed and restarted to previously saved position. There is a global timer that measures game time (can be obtain by the method \emph{GetTimeMillis}) when the game is running which is used by other systems such as the script system.

When the action is running physics and logic of entities are updated in the method \emph{Update} which means the corresponding messages are broadcast to all entities before and after the update of the physical engine.

Since the class \emph{Core::Game} registers the input listener to itself there are callbacks where it is possible to react to keyboard and mouse events such as a key or mouse button press/release or a mouse move. The corresponding information such as a current mouse position is available through the callback parameters.

If it is necessary to store some extra information that is shared among the game scenes (i.e. total score) the dynamic properties of this class should be used. There are template methods for getting or setting any kind of value under its name as well as methods for deleting one or all properties and for loading and saving them from/to a file. The properties are now stored along with other game stuff.

\section{Loading screen}

The \emph{Core::LoadingScreen} class loads resource groups into the memory and displays information about the loading progress. It is connected to the resource manager that calls its listener methods when a resource or a whole resource group is going to be loaded or has been already loaded so it can update progress information.

First it is necessary to create an instance of the \emph{Core::LoadingScreen} class. The only method of this class that should be called explicitly is the \emph{DoLoading} one. The first parameter represents the kind of data to be loaded. Basic resources containing necessary pictures for a loading screen must be loaded first, then general resources needed in most of the states of the application should be loaded. If the editor should be available its resources must be in the memory too. The last usage of this method is the loading of scenes where the second parameter (a name of a scene) must be filled.

The \emph{DoLoading} method invokes the resource manager for loading corresponding resources and the manager calls callback methods informing about the state of loading. For each resource group the \emph{ResourceGroupLoadStarted} method is called first with the group name and a count of resources in the group. Then for each resource in the group the \emph{ResourceLoadStarted} method with a pointer to the resource class is called before the loading starts and the \emph{ResourceLoadEnded} method is called after the loading ends. Finally when a whole resource group is loaded the \emph{ResourceGroupLoadEnded} is called. Each of these methods calls the \emph{Draw} method that shows the loading progress to the user.

In the present implementation the loading progress is shown as a ring divided to eight parts that one of them is drawn brighter than the others. Once a while the next part (in a clockwise order) is selected as a brighter one. Since this implementation shows only that something is loading but not the real progress it can be changed if it is necessary.

\section{Configuration}
\label{sec:config}

The \emph{Core::Config} class allows storing a configuration data needed by various parts of the program. It serves as a proxy class between the engine and the RudeConfig library\cite{rudeconfig}. Supported data types are strings, integers and booleans and they are indexed by text keys and they can be grouped to named sections.

This class is initialized by a name of the file where data are or will be stored. Although changes to a configuration are saved when the class is being destructed it is possible to force it and get the result of this action by the method \emph{Save}.

There are several getter and setter methods for each data type that get or set data according to a key and a section name. A section parameter is optional, the section named \verb|General| is used as a default. The getter methods have also a default value parameter that is returned when a specific key and section do not exist in a configuration file. It is possible to get all keys in a specific section to a vector with the method \emph{GetSectionKeys} or remove one key (\emph{RemoveKey}) or a whole section (\emph{RemoveSection}).

\section{Project}

The \emph{Core::Project} class manages the project and its scenes both in the editor and in the game. There are methods for creating and opening a project in a specific path as well as closing it and getting or setting project information (a name, a version, an author). Other methods of this class manage scenes of the project -- creating, opening, saving, closing etc. Some methods like creating or saving scenes can be called only in the editor mode and are not accessible from scripts.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Loading screen] -- a screen visible during a loading of the game indicating a loading progress
  \item[Main loop] -- a code where an input from user is handled, an application logic is updated and a scene is drawn in a cycle until an application shut down
  \item[FPS] -- a count of frames per second that are drawn indicates a performance of a game
  \item[Render target] -- a region in an application window where a game content is drawn to
  \item[Resource] -- any kind of data that an application needs for its running (i.e. pictures, scripts, texts etc.)
  \item[Configuration data] -- data that parameterizes the application running (i.e. a screen resolution, a game language etc.)
  \item[Project] -- represents one game created in the editor that can be run independently, it is divided to scenes
  \item[Scene] -- represents one part of the game that is loaded at once (i.e. a game level, a game menu etc.)
\end{description}



\chapter{Gfx system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{GfxSystemClassDiagram.pdf}
	\caption{Class diagram of the GfxSystem namespace}
	\label{fig:gfxsystem-diagram}
\end{figure}

\section{Purpose of the graphic system}

The graphic system implements functionalities related to the rendering of game entities and the management of the application window. The design of this system is influenced by the requirement of platform independence. Note that the GUI system uses its own rendering system.

In the following sections the concept of viewports and render targets will be described as well as the process of rendering game entities, the way of creating the application window will be revealed and the management of meshes and textures will be introduced. In the last section there is a small glossary of used terms.

\section{Graphic viewport and render target}
\label{sec:render-target}

The \emph{GfxSystem::GfxViewport} class defines a place where all game entities will be rendered. It simply stores the information about a position and a size within the global window that can be obtained from some texture and also the data needed for drawing a grid which is useful in the edit mode. It has methods for getting and setting these properties as well as other ones for calculating its boundaries in the world or scene space.

For drawing the game entities it is also necessary to know from which position they are rendered so the \emph{GfxSyste::RenderTarget} type is defined which is a pair of a viewport and an entity handle that must point to an entity with a camera component. This type is used by renderer classes described below where it is indexed by the \emph{GfxSystem::RenderTargetID} type which is defined as an integer.

For easy moving and zooming a camera by a mouse in a render target the \emph{GfxSystem::DragDropCameraMover} class was defined. In its constructor or later by its setters it is possible to adjust a zoom sensitivity and a maximal and minimal allowed zoom.

\section{Renderer and scene manager}

The \emph{GfxSystem::GfxRenderer} is the main class that manages a rendering of entities to render targets. This is a platform independent abstract class handling a communication with other engine systems from which now derives only the \emph{GfxSystem::OglRenderer} class implementing a low level rendering in the OpenGL library\cite{opengl}. If it is necessary to implement a rendering for another library (i.e. DirectX) it should be done by deriving another class and implementing all abstract methods.

The abstract class has methods for managing its render targets, for drawing simple shapes as well as textures and meshes or for clearing the screen. The rendering must be started by the \emph{GfxRenderer::BeginRendering} method, then the current render target must be set and cleared. After everything is drawn the \emph{GfxRenderer::FinalizeRenderTarget} method must be called and then another render target is set or the whole rendering is finished by the \emph{GfxRenderer::EndRendering} method.

An important attribute of the \emph{GfxSystem::GfxRenderer} class is the point\-er to the \emph{GfxSystem::SceneMgr} class created on its initialization accessible by the \emph{GfxRenderer::GetSceneManager} method. This is the class to which all drawable components (sprites, models) must be registered along with a \emph{Transform} component of their entity by the \emph{SceneMgr::AddDrawable} method so then they are rendered by the \emph{SceneMgr::DrawVisibleDrawables} method if they are visible.

To provide debug drawing of physics entities the \emph{GfxSystem::PhysicsDraw} proxy class was defined and registered as an implementation of the \emph{b2\-Debug\-Draw} class from the Box2D library. All methods are redirected to corresponding methods in the \emph{GfxSystem::GfxRenderer} class.

\section{Application window}

The graphic system also manages creating and handling the application window which depends on the used operating system. This functionality is implemented by the \emph{GfxSystem::GfxWindow} class with the usage of the SDL library. This class has methods for getting and setting a window position, size and title or a visibility of a mouse cursor, toggling a fullscreen mode and handling system window events. It is also possible to register a screen listener represented by a class implementing the \emph{GfxSystem::IGfxWindowListener} interface. This class will be informed when the screen resolution is changed.

Note that the SDL library also provides features in low-level audio and input management but since audio is not yet implemented and input management is done by more specialized library, the only used SDL features used are window management and creating rendering context.

\section{Mesh and texture}

Meshes and textures are essential parts of the \emph{Model} and \emph{Sprite} components. They can be loaded via the \emph{GfxSystem::Mesh} and \emph{GfxSystem::Texture} classes that inherit from the \emph{ResourceSystem::Resource} class (for more information see chapter about the resource system).

On loading of a texture resource the \emph{GfxRenderer::LoadTexture} abstract method is called. For OpenGL implementation the SOIL library is used which is a tiny C library used for uploading textures into the OpenGL and which supports most of the common image formats.

For defining meshes the Wavefront OBJ file format \cite{obj} is used. Every texture used in the model definition is automatically loaded as a resource.
 
\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Viewport] -- a region of the application window where entities are rendered to
  \item[Render target] -- a pair or a viewport and a camera
  \item[Sprite] -- a component for showing an entity as an image (even animated or transparent)
  \item[Model] -- a component for showing an entity as a 3D-model
  \item[Texture] -- a bitmap image applied to a surface of a graphic object
  \item[Mesh] -- a collection of vertices, edges and faces that defines the shape of a polyhedral object
\end{description}



\chapter{Entity system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EntitySystemClassDiagram.pdf}
	\caption{Class diagram of the Entity system namespace}
	\label{fig:entitysystem-diagram}
\end{figure}

\section{Purpose of the entity system}

The entity system creates a common interface for a definition of all game objects such as a game environment, a player character, a camera etc. and their behavior such as a drawing on a screen, an interaction with other objects etc. The object creation is based on a composition of simple functionalities that can be reused in many of them. The advantage of this unified system is an easy creating and editing of new objects from the game editor or from scripts, the disadvantage is a slower access to the object properties and behavior. It cooperates with the other systems like the graphics one for displaying objects or the script one for an interaction from scripts.

In the following sections the system of components and entities will be described as well as picking entities and organizing them in layers. In the last section there is a small glossary of used terms.

\section{Components and their manager}

Every game object is represented by an entity which is a compound of components that provide it various functionalities. A component can have several properties (and functions) which can be read or written (called) via their getters and setters (or functions themselves) and which are accessible through their unique name. It can also react to sent messages such as an initialization, a drawing, a logic update etc. by its own behavior. Component properties and behaviors are accessible only through an owner entity, so it is possible to read or write a specific property of an entity if it contains a component with this property and it is also possible to send a message to an entity which dispatches it to all its components that can react on it.

The \emph{EntitySystem::Component} class is a base class for all components used in the entity system. It inherits from the \emph{Reflection::RTTIBaseClass} class which provides the methods for working with RTTI (registering properties and functions of component, see section 
%todo \ref{utils-rtti}
).
It has methods for getting the owner entity, the component type (defined in ComponentEnums.h) and the component property from its name and for posting a message to the owner entity. It also introduces methods that should be overridden by specific components used for handling messages and the component creation and destruction (see the Extending Ocerus document).

The \emph{EntitySystem::ComponentMgr} is a singleton class that manages instances of all entity components in the entity system. Internally it stores mapping from all entities to lists of their components. It provides methods for adding a new component of a certain type to an entity and listing or deleting all or specific components from an entity. For passing all components of an entity the \emph{EntitySystem::EntityComponentsIterator} iterator is used that encapsulates a standard iterator (for example it has the \emph{HasMore} method which returns whether the iterator is at the end of the component list).

\section{Entities and their manager}

An entity is represented by the \emph{EntitySystem::EntityHandle} class which sto\-res only an ID of the entity and provides methods that mostly calls corresponding methods of the entity manager with its ID. This class has also static methods that ensure all IDs in the system are unique.

For the creation of one entity the \emph{EntitySystem::EntityDescription} class is used that is basically a collection of component types. There are methods for adding a component type and setting a name and a prototype of the entity. It is also possible to set if the created object will be an instance or a prototype of an entity. Prototypes of entities are used to propagate changes of their shared properties to the instances that are linked to them so it is possible to change properties of many entities at once. Instances must have all components that has their prototype in the same order but they can also have own additional components that must be added after the compulsory ones.

It is possible to send messages to entities so there is the \emph{EntitySystem::EntityMessage} structure that represents them. It consists of the message type defined in EntityMessageTypes.h and the message parameters that are an instance of the \emph{Reflection::PropertyFunctionParameters} class. To add an parameter of any type defined in PropertyTypes.h the \emph{PushParameter} method can be called with a value as first argument or the \emph{operator}$<<$ can be used. There is also a method that checks whether the actual parameters are of the correct types according to the definition of message type (see section the Extending Ocerus document for more information).

All entities are managed by the \emph{EntitySystem::EntityMgr} class that stores necessary information about them in maps indexed by their ID. The most of its methods has the entity handle as the first parameter that means it applies on the entity of the ID got from the handle. There are methods for creating entities from an entity description, a prototype, another entity or an XML resource and for destroying them. Other methods manages entity prototypes -- it is possible to link/unlink an instance to/from a prototype, to set a property as (non)shared, to invoke an update of instances of a specific prototype and to create a prototype from a specific entity. Finally there are methods for getting entity properties even of a specific component (in case of two or more properties of a same name in different components), for registering and unregistering dynamic properties, for posting and broadcasting messages to entities and for adding, listing and removing components of a specific entity.

\section{Entity picker}

The entity picker implemented by the \emph{EntitySystem::EntityPicker} class is a mechanism to select one or more entities based on their location. If the picker is used to select a single entity all it needs is a position in the world coordinates. The query then returns the found entity or none. This feature can be used to select the entity the mouse cursor is currently hovering over. The cursor position must be translated into the world coordinates via the rendering subsystem and its viewports. If the picker is used to select more entities a query rectangle (along with its angle) must be defined. This feature can be used to implement a multiselection using the mouse or gamepad. It is also possible to define two layers between which the picked entities must lie.

\section{Layer manager}

Every entity with the \emph{Transform} component has the layer property which is an ID of a layer from the layer manager implemented by the \emph{EntitySystem::LayerMgr} class. This class has many methods for creating, moving and destroying layers as well as getting and setting their names and visibility, entities in a specified layer and choosing the current active layer. There are also methods for loading and saving stored information from/to a file.

There is always one initial layer with the ID equal to 0 which cannot be deleted and other layers are either before (foreground, positive ID) or behind (background, negative ID) it.

\section{Glossary}

This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Entity property] -- a named pair of a getter and a setter function of a specific type with certain access rights
  \item[Entity function] -- a named link to a function with a \emph{Reflection::Property\-FunctionParameters} parameter and certain access rights
  \item[Entity message] -- a structure that stores a message type from EntityMessageTypes.h and message parameters
  \item[Component] -- a class which has registered functions and properties, that can be read and written via their getters and setters, and which can handle received messages
  \item[Entity] -- a compound of one or more components, that provide specific functionalities, represented by a unique ID, it is possible to post a message to it
  \item[Prototype] -- changes of shared property values of this entity are propagated to the linked entities
  \item[Entity picker] -- a mechanism to select one or more entities
  \item[Layer] -- a number which defines a z-coordinate of an entity in a scene
\end{description}


\chapter{GUI system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{GUISystemClassDiagram.pdf}
	\caption{Class diagram of the GUI system namespace}
	\label{fig:guisystem-diagram}
\end{figure}

\section{Purpose of the GUI system}

The GUI system provides creating and drawing a graphic user interface based on the CEGUI library for the editor and the game itself. It also manages a user interaction with GUI elements, element layouts, viewports and GUI console.

In the following sections the GUI manager and its resource and script providers will be described as well as concept of layouts, viewports, popup menus and the GUI console. In the last section there is a small glossary of used terms.

\section{GUI manager}

The main class of the GUI system is the \emph{GUISystem::GUIMgr} which is a connector for drawing, input handling and resource and script providing between the CEGUI library and the engine. During its creation it creates a CEGUI renderer, connects the resource manager with the CEGUI system via the \emph{GUISystem::Resource\-Provider} class (see section \ref{sec:gui-resources}), connects the script manager with the CEGUI system via the \emph{GUISystem::ScriptProvider} class (see section \ref{sec:gui-script}), provides itself as an input and screen listener and creates the GUI console which is then accessible via the \emph{GUIMgr::GetConsole} method (see section \ref{sec:gui-console}). On its initialization (\emph{GUIMgr::Init}) it loads necessary GUI resources (schemes, image sets, fonts, layouts and looknfeels) and creates a root window.

For loading a root layout from a file the method \emph{GUIMgr::LoadRootLayout} is provided with only one parameter specifying a name of a file where a layout is defined. This method calls the \emph{GUIMgr::LoadWindowLayout} which is a common method for loading a window layout from a file that also provides a translation of all texts via the string manager. There are also methods for unloading and getting the current root layout. For more information about layouts see section \ref{sec:gui-layouts}.

There are two methods called in the application main loop. First the \emph{GUIMgr::Update} updates time of the GUI system, and then the \emph{GUIMgr::Render\-GUI} draws the whole GUI. There are several input callback methods that converts an OIS library representation of keyboard and mouse events to a CEGUI one and forwards them to the CEGUI library. It is possible to get the currently processing input event by the \emph{GUIMgr::GetCurrentInputEvent} method. There is also a callback method for a resolution change that forwards this information to the CEGUI library too.

\section{GUI resources}
\label{sec:gui-resources}

A GUI resource is represented by the \emph{GUISystem::CEGUIResource} class. Since the CEGUI library is not designed to allow an automatic resource unloading and reloading on demand this class only loads raw data by the resource manager and after providing them to the CEGUI library by the \emph{CEGUIResource::GetResource} method it unloads them.

When the CEGUI library needs a resource it calls an appropriate method of a resource provider class provided on an initialization of the library. In this engine it is the \emph{GUISystem::ResourceProvider} class and its method \emph{ResourceProvider::loadRawDataContainer} that gets the resource from the resource manager and forwards its data to the library.

\section{Script provider}
\label{sec:gui-script}

For a connection of the CEGUI library and the script system the \emph{GUISystem::ScriptProvider} class is introduced implementing the \emph{CEGUI::ScriptModule} interface. The only method from this interface which truly needs an implementation is the \emph{ScriptModule::subscribeEvent} which provides a name of event, a name of function that should handle it and an object to which the name of event and an object with a callback method should be subscribed.

This transformation is implemented by the \emph{GUISystem::ScriptCallback} class which stores the function name given in its constructor and which calls an appropriate script function as a callback. It calls a function from the script module associated with the GUI layout component of the layout which gets the event or a function from the \verb/GuiCallback.as/ module as a default. For more information see the User Guide document.
%todo the User Guide document???

\section{Layouts}
\label{sec:gui-layouts}

A GUI layout defines a composition of GUI elements including their properties such as position, size and content and their behavior. Their properties can be defined in an external XML file but more dynamic compositions need also a lot of a code support, their behavior can be defined in an external script file but more complicated reactions have to be also native coded.

As an example that can be used both in the editor and in the game the \emph{GUISystem::MessageBox} class was created which provides a modal dialog for informing the user or for asking the user a question and receiving the answer. The basic layout with all possible buttons is specified in an XML file which is loaded in a class constructor where these buttons are mapped to the correspondent objects and displayed according to a message box type. Setting of a message text (\emph{MessageBox::SetText}) also changes a static text GUI element specified in an XML file. The behavior after the user clicks to one of buttons is defined by a callback function that can be registered by the \emph{MessageBox::RegisterCallback} method and that gets the kind of the chosen button and the ID specified in a constructor parameter. For an easier usage there is the global function \emph{GUISystem::ShowMessageBox} that takes all necessary parameters (a text, a kind of a message box, a callback and an ID) and creates and shows an appropriate message box. A similar concept has the \emph{GUISystem::PromptBox} class providing a modal dialog that asks for a text input from the user and the \emph{GUISystem::FolderSelector} class providing a modal dialog for selecting a folder.

Another example is the \emph{GUISystem::VerticalLayout} class that helps to keep GUI elements positioned in a vertical layout and automatically repositions them when one of them changes its size. In its constructor the container in which all child elements should be managed is specified, and then the \emph{VerticalLayout::AddChildWindow} method is used for adding them. It is also possible to set spacing between them and there is a method for updating a layout. It is obvious that this layout is defined without any XML file. For more information about creating own layouts see the User Guide document.
%todo the User Guide document???

\section{Viewports}

The \emph{GUISystem::ViewportWindow} class represents a viewport window with a frame where a scene is rendered by the graphic system. For defining a position, an angle and a zoom of a view of a scene which will be displayed in the viewport a camera in form of an entity with a camera component must be set by the \emph{ViewportWindow::SetCamera} method. It is possible to define whether the viewport allows a direct edit of a view and displayed entities by the \emph{ViewportWindow::SetMovableContent} method. For example in the editor there are two viewports -- in the bottom one the scene can be edited whereas in the top one the result is only shown. The method \emph{ViewportWindow::AddInputListener} registers the input listener so any class can react to mouse and keyboard actions done in the viewport when it has been activated by the method \emph{ViewportWindow::Activate}.

\section{Popup menus}

The \emph{GUISystem::PopupMgr} class provides methods creating (\emph{Popup\-Mgr\-::\-Create\-Popup\-Menu} / \emph{PopupMgr::CreateMenuItem}) and destroying (\emph{PopupMgr::DestroyPopupMenu} / \emph{PopupMgr::DestroyMenuItem}) popup menu and its items as well as showing (\emph{PopupMgr::ShowPopup}) and hiding (\emph{PopupMgr::HidePopup}) it and it also cares about calling a proper callback when a menu item is clicked on. The callback method is provided to the manager when the popup menu is being opened by the \emph{PopupMgr::ShowPopup} method.

\section{GUI console}
\label{sec:gui-console}

The \emph{GUISystem::GUIConsole} class manages the console accessible both in the game and in the editor. The console receives all messages from the log system via the method \emph{GUIConsole::AppendLogMessage} and shows those ones which have an equal or higher level than previously set by the \emph{GUIConsole::SetLogLevelTreshold} method. In addition the user can type commands to the console prompt line which are sent to the script system as a body of a method without parameters that is immediately built and run and if there is a call of the \verb/Print/ function its content will be printed to the console via the \emph{GUIConsole::AppendScriptMessage} method. For better usage of the console a history of previously typed commands is stored and can be revealed by up and down arrows. The console can be shown or hide by \emph{GUIConsole::ToggleConsole} method.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[GUI] -- a graphic user interface
  \item[GUI element] -- an element from which the whole GUI is created such as label, edit box, list etc.
  \item[Layout] -- a composition of GUI elements including definition of their properties and behavior
  \item[Viewport] -- a GUI element where a scene can be rendered by the graphic system
  \item[GUI console] -- a window where log and script messages immediately appears and which allows an input of script commands
  \item[GUI event] -- a significant situation made by the user input such as a mouse click or a keyboard press
  \item[Callback] -- a function or method that is called as a reaction to a GUI event
  \item[Scheme] -- a definition of connections between a physical window type and a window look
\end{description}


%% A small distance to the other stuff in the table of contents (toc)
\addtocontents{toc}{\protect\vspace*{\baselineskip}}

%% The Bibliography 
\begin{thebibliography}{9}
\addcontentsline{toc}{chapter}{Bibliography} %'Bibliography' into toc
\bibitem {angelscript}AngelScript -- http://www.angelcode.com/angelscript
\bibitem {boost}Boost -- http://www.boost.org
\bibitem {box2d}Box2D -- http://www.box2d.org
\bibitem {cegui}CEGUI -- http://www.cegui.org.uk
\bibitem {dbglib}DbgLib -- http://dbg.sourceforge.net
\bibitem {expat}Expat -- http://expat.sourceforge.net
\bibitem {ois}OIS -- http://sourceforge.net/projects/wgois
\bibitem {opengl}OpenGL -- http://www.opengl.org
\bibitem {rthprofiler}Real-Time Hierarchical Profiling -- Greg Hjelstrom, Byon Garrabrant: Game Programming Gems 3, Charles River Media, 2002, ISBN: 1584502339
\bibitem {rudeconfig}RudeConfig -- http://rudeserver.com/config
\bibitem {sdl}SDL -- http://www.libsdl.org
\bibitem {soil}SOIL -- http://www.lonesock.net/soil.html
\bibitem {unittest}UnitTest++ -- http://unittest-cpp.sourceforge.net
\bibitem {gpg5}Kim Pallister: Game Programming Gems 5, Charles River Media, 2005, ISBN: 1584503521
\bibitem {tree}Kasper Peeters, http://www.aei.mpg.de/~peekas/tree
\bibitem {allocator}http://www.sjbrown.co.uk/2004/05/01/pooled-allocators-for-the-stl
\bibitem {glew}http://glew.sourceforge.net
\bibitem {objloader}http://www.dhpoware.com
\bibitem {pluscallback}http://codeplea.com/pluscallback
\bibitem {obj}Wavefront OBJ file structure -- http://en.wikipedia.org/wiki/Obj
\bibitem {cegui-doc}CEGUI documentation -- http://cegui.org.uk/api\_reference/index.html
\bibitem {angelscript-doc}AngelScript documentation -- file /AngelScript/index.html
\bibitem {ISO-639-1}ISO 639-1 -- http://en.wikipedia.org/wiki/List\_of\_ISO\_639-1\_codes
\bibitem {ISO-3166-1}ISO 3166-1 alpha-2 -- http://en.wikipedia.org/wiki/ISO\_3166-1\_alpha-2
\end{thebibliography}

%% The List of Figures
\clearpage
\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures

%% The List of Tables
\clearpage
\addcontentsline{toc}{chapter}{List of Tables}
\listoftables

\end{document}