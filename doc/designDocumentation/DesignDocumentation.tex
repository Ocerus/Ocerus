\newcommand{\TitleText}{Ocerus Design Documentation}
\documentclass[a4paper,12pt]{report}
\input{../CommonHeader.tex}


\chapter{Introduction}

This is the design documentation of the project Ocerus. It should be read by developers who want to change some parts of the game engine or to add new features to it. It may be useful for everyone who is curious how this application is designed or how libraries listed in the table \ref{tab:library-list} can be used.

\section{Project architecture}

The project Ocerus is logically divided into several relatively independent systems which cooperate with each other. Every system maintains its part of the application such as graphics, resources, scripts etc. and provides it to other ones. In the figure \ref{fig:system-connection} the relations among all systems are displayed with a brief description of what the systems provide to each other.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{SystemConnection.pdf}
	\caption{Dependencies among the systems}
	\label{fig:system-connection}
\end{figure}

The project has not been created from scratch but it is based on several libraries to allow the developers to focus on important features for the end users and top-level design rather than low-level programming. All used libraries support many platforms, have free licenses and have been heavily tested in a lot of other projects. All of them are used directly by one to three subsystems except the library for unit testing. The library dependencies of each system are displayed in the figure \ref{fig:library-dependence}.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{LibraryDependence.pdf}
	\caption{Library dependencies of the project systems}
	\label{fig:library-dependence}
\end{figure}

In the table \ref{tab:library-list} a brief description of all used libraries is provided.

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			Library & Description\\
			\hline
			AngelScript\cite{angelscript} & a script engine with an own language\\
			Boost\cite{boost} & a package of helper data structures and algorithms\\
			Box2D\cite{box2d} & a library providing 2D real-time physics\\
			CEGUI\cite{cegui} & a graphic user interface engine\\
			DbgLib\cite{dbglib} & tools for a real-time debugging and crash dumps\\
			Expat\cite{expat} & a XML parser\\
			OIS\cite{ois} & a library for managing events from input devices\\
			OpenGL\cite{opengl} & an API for 2D and 3D graphics\\
			RTHProfiler\cite{rthprofiler} & an interactive real-time profiling of code\\
			RudeConfig\cite{rudeconfig} & a library for managing configure files\\
			SDL\cite{sdl} & a tool for an easier graphic rendering\\
			SOIL\cite{soil} & a library for loading textures of various formats\\
			UnitTest++\cite{unittest} & a framework for a unit testing\\
			\hline
		\end{tabular}
		%}
	\caption[Used libraries with the description]{Used libraries with the description}
	\label{tab:library-list}
\end{table}

Except these libraries, some small pieces of a third party code that were used are listed in the table \ref{tab:code-list}.

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.28\hsize}|p{0.65\hsize}|}
			\hline
			Third party code & Description\\
			\hline
			Properties, RTTI\cite{gpg5} & a basic concept of entity properties and run-time type information\\
			Tree\cite{tree} & an STL-like container class for n-ary trees\\
			FreeList\cite{gpg5} & free lists / memory pooling implementation\\
			Pool allocator\cite{allocator} & pooled allocators for STL\\
			GLEW\cite{glew} & the OpenGL extension wrangler library\\
			OBJ loader\cite{objloader} & the Wavefront OBJ file loader\\
			PlusCallback\cite{pluscallback} & an easy use of function and method callbacks\\
			Script builder, script string\cite{angelscript} & an implementation of strings in the script engine and building more files to a script module\\
			\hline
		\end{tabular}
		%}
	\caption[Third party code with the description]{Third party code with the description}
	\label{tab:code-list}
\end{table}

In the following chapters each of the project systems will be described from the design view. At the beginning of each chapter there is an UML class diagram and a paragraph about a purpose of the described system and at the end of most chapters there is a small glossary of terms used in that chapter. In UML class diagrams, two specific stereotypes are used. The first one is the \verb/<<singleton>>/ stereotype used in classes derived from the \emph{Utils::Singleton<T>} class, which is an implementation of the singleton design pattern. The second one is the \verb/<<external>>/ stereotype used in classes defined and implemented in some library specified in the table \ref{tab:library-list}.


\chapter{Core}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{CoreClassDiagram.pdf}
	\caption{Class diagram of the Core namespace}
	\label{fig:core-diagram}
\end{figure}

The Core namespace is the main part of the engine. It contains its entry point and other classes closely related to the application itself, its states and configuration. Its main task is to initialize and configure other engine systems, invoke their update and draw methods in the main loop and in the end correctly finalize them.

\section{Application}

When the program starts, it creates an instance of the class \emph{Core::Application}, initializes it by calling its method \emph{Init} and calls the \emph{RunMainLoop} method which runs until the application is shutdown, then the instance is deleted and the program finishes (see figure \ref{fig:application-states}).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ApplicationStates.pdf}
	\caption{Possible states of the Application class}
	\label{fig:application-states}
\end{figure}

On the initialization of the application, the configuration is read (see section \ref{sec:config}) and all engine systems are created and initialized as well as the loading screen and game classes. The state of application is changed to \emph{loading} and the main loop is running until the state is changed to \emph{shutdown}. At the main loop window messages are processed, performance statistic are updated and other engine systems including the game class are loaded (in the \emph{loading} state) or updated and drawn (in the \emph{game} state).

In the application class there are also methods for getting an average and last FPS statistic, methods for showing and hiding a debug console as well as writing message to it or a method for executing an external file. There are also the variables indicating whether the current application instance includes the editor (in a game distribution the editor should be disabled) and whether the editor is currently turned on so the game is running only in a small window instead of a full screen mode. From this class it is possible to get the current project as well as deploy it to the specific platform and destination.

\section{Game}

The \emph{Core::Game} class manages the most important stuff needed to run the game such as drawing a scene, updating physics and logic of entities, measuring time, handling a game action or resolving an user interaction. Of course it mostly delegates this work to other parts of the engine (see table \ref{tab:game-relation}).

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.18\hsize}|p{0.75\hsize}|}
			\hline
			Design entity & Relation to the Game class\\
			\hline
			\multicolumn{2}{|c|}{Game is affected by}\\
			\hline
			Application & initializes, updates, destroys it\\
			Editor & sets render target, can delegate input\\
			InputMgr & can delegate input\\
			ResourceMgr & loads the saved game\\
			\hline
			\multicolumn{2}{|c|}{Game affects what}\\
			\hline
			GfxRenderer & invokes drawing entities\\
			Physics & initializes, updates and destroys it, processes its events\\
			EntityMgr & broadcasts update and draw messages to entities\\
			ScriptMgr & gives the game time\\
			GUIMgr & stores the root window for the game GUI\\
			\hline
		\end{tabular}
		%}
	\caption[Relations of the Game class]{Relations of the Game class}
	\label{tab:game-relation}
\end{table}


Before the game initialization at the method \emph{Init}, a valid render target (a camera and a viewport, see section \ref{sec:render-target}) must be set by the method \emph{SetRenderTarget} or the default one must be created by the method \emph{CreateDefaultRenderTarget} to know where to draw the game content. This is done by the \emph{Core::Project} class when a scene is being opened and it can delegate it to the editor if it is available. Then physics, time, an action etc. are initialized and in the \emph{Update} method called in the main loop they are updated.

The drawing of a scene is invoked in the method \emph{Draw}. The render target is cleared, all entities in the current scene are drawn by a renderer and the rendering is finalized.

There are several methods for handling a game action that can be in two states -- paused or running. When the action is running, the physics and the logic of entities is being updated in the method \emph{Update}, which means that the corresponding messages are being broadcast to all entities before and after the update of the physical engine. The action can be paused, resumed and restarted to a previously saved position. There is a global timer that measures the game time (can be obtained by the method \emph{GetTimeMillis}), when the game is running, which is used by other systems, such as the script system.

Since the class \emph{Core::Game} registers the input listener to itself, there are callbacks where it is possible to react to keyboard and mouse events such as a key or a mouse button press/release or a mouse move. The corresponding information such as a current mouse position is available through the callback parameters.

If it is necessary to store some extra information that is shared among the game scenes (i.e. total score) the dynamic properties of this class should be used. There are template methods for getting or setting any kind of value under its name as well as methods for deleting one or all properties and for loading and saving them from/to a file. The properties are now stored along with other game stuff. For more information about using dynamic properties see the section \ref{sec:utils-properties}.

\section{Loading screen}

The \emph{Core::LoadingScreen} class loads resource groups into the memory and displays information about the loading progress. It is connected to the resource manager that calls its listener methods when a resource or a whole resource group is going to be loaded or has been already loaded so it can update the progress information.

First it is necessary to create an instance of the \emph{Core::LoadingScreen} class. The only method of this class that should be called explicitly is the \emph{DoLoading} one. The first parameter represents the kind of data to be loaded. Basic resources containing necessary pictures for a loading screen must be loaded first, then general resources needed in most of the states of the application should be loaded. If the editor should be available, its resources must be in the memory too. The last usage of this method is the loading of scenes where the second parameter (a name of a scene) must be filled.

The \emph{DoLoading} method invokes the resource manager for loading corresponding resources and the manager calls callback methods informing about the state of loading. For each resource group the \emph{ResourceGroupLoadStarted} method is called first with the group name and a count of resources in the group. Then for each resource in the group the \emph{ResourceLoadStarted} method with a pointer to the resource class is called before the loading starts and the \emph{ResourceLoadEnded} method is called after the loading ends. Finally when a whole resource group is loaded the \emph{ResourceGroupLoadEnded} is called. Each of these methods calls the \emph{Draw} method that shows the loading progress to the user.

In the present implementation, the loading progress is shown as a ring divided into eight parts and one of them is drawn brighter than the others. Once in a while the next part (in a clockwise order) is selected as a brighter one. Since this implementation shows only that something is loading, but not the real progress, it can be changed if it is necessary.

\section{Configuration}
\label{sec:config}

The \emph{Core::Config} class allows storing a configuration data needed by various parts of the program. It serves as a proxy class between the engine and the RudeConfig library\cite{rudeconfig}. Supported data types are strings, integers and booleans and they are indexed by text keys and they can be grouped to named sections.

This class is initialized by a name of the file where data are or will be stored. Although changes to a configuration are saved when the class is being destructed it is possible to force it and get the result of this action by the method \emph{Save}.

There are several getter and setter methods for each data type that get or set the data according to a key and a section name. A section parameter is optional, the section named \verb|General| is used as a default. The getter methods have also a default value parameter that is returned when a specific key and section do not exist in a configuration file. It is possible to get all keys in a specific section to a vector with the method \emph{GetSectionKeys} or remove one key (\emph{RemoveKey}) or a whole section (\emph{RemoveSection}).

\section{Project}

The \emph{Core::Project} class manages the project and its scenes in both the editor and the game. There are methods for creating and opening a project in a specific path as well as closing it and getting or setting project information (a name, a version, an author). Other methods of this class manage scenes of the project -- creating, opening, saving, closing etc. Some methods like creating or saving scenes can be called only in the editor mode and are not accessible from scripts.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Loading screen] -- a screen visible during a loading of the game indicating a loading progress
  \item[Main loop] -- a code where an input from user is handled, an application logic is updated and a scene is drawn in a cycle until an application shuts down
  \item[FPS] -- a count of frames per second that are drawn indicates a performance of a game
  \item[Render target] -- a region in an application window where a game content is drawn to
  \item[Resource] -- any kind of data that an application needs for its running (i.e. pictures, scripts, texts etc.)
  \item[Configuration data] -- data that parametrizes the application running (i.e. a screen resolution, a game language etc.)
  \item[Project] -- represents one game created in the editor that can be run independently, it is divided to scenes
  \item[Scene] -- represents one part of the game that is loaded at once (i.e. a game level, a game menu etc.)
\end{description}


\chapter{Entity system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EntitySystemClassDiagram.pdf}
	\caption{Class diagram of the Entity system namespace}
	\label{fig:entitysystem-diagram}
\end{figure}

The entity system creates a common interface for a definition of all game objects such as a game environment, a player character, a camera etc. and their behavior such as a drawing on a screen, an interaction with other objects etc. The object creation is based on a composition of simple functionalities that can be reused in many of them. The advantage of this unified system is an easy creating and editing of new objects from the game editor or from scripts. The disadvantage is a slower access to the object properties and behavior. It cooperates with the other systems like the graphics one for displaying objects or the script one for an interaction from scripts.

\section{Components and their manager}

Every game object is represented by an entity, which is a compound of components that provides it with various functionalities. A component can have several properties (and functions), which can be read or written (called) via their getters and setters (or functions themselves), and which are accessible through their unique name. It can also react to sent messages such as an initialization, a drawing, a logic update etc. by its own behavior. Component properties and behaviors are accessible only through an owner entity, so it is possible to read or write a specific property of an entity, if it contains a component with this property and it is also possible to send a message to an entity that dispatches it to all its components that can react on it.

The \emph{EntitySystem::Component} class is a base class for all components used in the entity system. It inherits from the \emph{Reflection::RTTIBaseClass} class, which provides the methods for working with RTTI (registering properties and functions of component, see section \ref{sec:utils-rtti}). It has methods for getting the owner entity, the component type (defined in ComponentEnums.h) and the component property from its name and for posting a message to the owner entity. It also introduces methods, which should be overridden by specific components, that are used for handling messages and the component creation and destruction (see the Extending Ocerus document).

The \emph{EntitySystem::ComponentMgr} is a singleton class that manages instances of all entity components in the entity system (see the figure \ref{fig:entity-component-managers-diagram}). Internally it stores mapping from all entities to lists of their components. It provides methods for adding a new component of a certain type to an entity and listing or deleting all or specific components from an entity. For passing all components of an entity the \emph{EntitySystem::EntityComponentsIterator} iterator, which encapsulates a standard iterator, is used(for example it has the \emph{HasMore} method which returns whether the iterator is at the end of the component list).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EntityAndComponentManagers.pdf}
	\caption{Objects managed by entity and component managers}
	\label{fig:entity-component-managers-diagram}
\end{figure}

\section{Entities and their manager}

An entity is represented by the \emph{EntitySystem::EntityHandle} class which sto\-res only an ID of the entity and provides methods that mostly calls corresponding methods of the entity manager with its ID. This class has also static methods that ensure that all IDs in the system are unique.

For the creation of one entity, the \emph{EntitySystem::EntityDescription} class is used. It is basically a collection of component types. There are methods for adding a component type and setting a name and a prototype of the entity. It is also possible to set whether the created object will be an instance or a prototype of an entity. Prototypes of entities are used to propagate changes of their shared properties to the instances that are linked to them so it is possible to change properties of many entities at once. Instances must have all components that has their prototype in the same order, but they can also have own additional components that must be added after the compulsory ones.

It is possible to send messages to entities so there is the \emph{EntitySystem::EntityMessage} structure that represents them. It consists of the message type defined in EntityMessageTypes.h and the message parameters that are an instance of the \emph{Reflection::PropertyFunctionParameters} class. To add a parameter of any type defined in PropertyTypes.h, the \emph{PushParameter} method can be called with a value as first argument, or the \emph{operator}$<<$ can be used. There is also a method that checks whether the actual parameters are of the correct types according to the definition of message type (see section the Extending Ocerus document for more information).

All entities are managed by the \emph{EntitySystem::EntityMgr} class that stores necessary information about them in maps indexed by their ID (see the figure \ref{fig:entity-component-managers-diagram}). The most of its methods has the entity handle as the first parameter that means it applies on the entity of the ID got from the handle. There are methods for creating entities from an entity description, a prototype, another entity or an XML resource and for destroying them. Other methods manages entity prototypes -- it is possible to link/unlink an instance to/from a prototype, to set a property as (non)shared, to invoke an update of instances of a specific prototype and to create a prototype from a specific entity. Finally, there are methods for getting entity properties even of a specific component (in case of two or more properties of a same name in different components), for registering and unregistering dynamic properties, for posting and broadcasting messages to entities and for adding, listing and removing components of a specific entity (see the figure \ref{fig:entity-communication-sequence} for implementation details).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EntityCommunicationSequence.pdf}
	\caption[The entity communication sequence diagram]{Process of getting an entity property and sending a message to an entity}
	\label{fig:entity-communication-sequence}
\end{figure}

\section{Entity picker}

The entity picker implemented by the \emph{EntitySystem::EntityPicker} class is a mechanism to select one or more entities based on their location. If the picker is used to select a single entity, all it needs is a position in the world coordinates. The query then returns the found entity or none. This feature can be used to select the entity the mouse cursor is currently hovering over. The cursor position must be translated into the world coordinates via the rendering subsystem and its viewports. If the picker is used to select more entities, a query rectangle (along with its angle) must be defined. This feature can be used to implement a multiselection using the mouse or gamepad. It is also possible to define two layers, between which the picked entities must lie.

\section{Layer manager}

Every entity with the \emph{Transform} component has the layer property which is an ID of a layer from the layer manager implemented by the \emph{EntitySystem::LayerMgr} class. This class has many methods for creating, moving and destroying layers as well as getting and setting their names and visibility, entities in a specified layer and choosing the current active layer. There are also methods for loading and saving stored information from/to a file.

There is always one initial layer with the ID equal to 0 which cannot be deleted and other layers are either in front (foreground, positive ID) or behind (background, negative ID) it.

\section{Glossary}

This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Entity property] -- a named pair of a getter and a setter function of a specific type with certain access rights
  \item[Entity function] -- a named link to a function with a \emph{Reflection::Property\-FunctionParameters} parameter and certain access rights
  \item[Entity message] -- a structure that stores a message type from EntityMessageTypes.h and message parameters
  \item[Component] -- a class which has registered functions and properties, that can be read and written via their getters and setters, and which can handle received messages
  \item[Entity] -- a compound of one or more components, that provide specific functionalities, represented by a unique ID, it is possible to post a message to it
  \item[Prototype] -- changes of shared property values of this entity are propagated to the linked entities
  \item[Entity picker] -- a mechanism to select one or more entities
  \item[Layer] -- a number which defines a z-coordinate of an entity in a scene
\end{description}



\chapter{Gfx system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{GfxSystemClassDiagram.pdf}
	\caption{Class diagram of the GfxSystem namespace}
	\label{fig:gfxsystem-diagram}
\end{figure}

The graphic system implements functionalities related to the rendering of game entities and the management of the application window. Note that the GUI system uses its own rendering system.

\section{Graphic viewport and render target}
\label{sec:render-target}

The \emph{GfxSystem::GfxViewport} class defines a place where all game entities will be rendered. It simply stores the information about a position and a size within the global window, which can be obtained from some texture, and also the data needed for drawing a grid, which is useful in the edit mode. It has methods for getting and setting these properties as well as other ones for calculating its boundaries in the world or scene space.

For drawing the game entities it is also necessary to know from which position and where they are rendered, so the \emph{GfxSystem::RenderTarget} type is defined, which is a pair of a viewport and an entity handle that must point to an entity with a camera component. This type is used by renderer classes described below where it is indexed by the \emph{GfxSystem::RenderTargetID} type defined as an integer.

For easy moving and zooming a camera by a mouse in a render target the \emph{GfxSystem::DragDropCameraMover} class was defined. In its constructor or later by its setters it is possible to adjust a zoom sensitivity and a maximal and minimal allowed zoom.

\section{Renderer and scene manager}

The \emph{GfxSystem::GfxRenderer} is the main class that manages a rendering of entities to render targets. This is a platform independent abstract class handling a communication with other engine systems from which now derives only the \emph{GfxSystem::OglRenderer} class implementing a low level rendering in the OpenGL library\cite{opengl}. If it is necessary to implement a rendering for another library (i.e. DirectX) it should be done by deriving another class and implementing all abstract methods.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{RenderingActivityDiagram.pdf}
	\caption{Activity diagram of the rendering process}
	\label{fig:rendering-diagram}
\end{figure}

The abstract class has methods for managing its render targets, for drawing simple shapes as well as textures and meshes or for clearing the screen. As the figure \ref{fig:rendering-diagram} shows, the rendering must be started by the \emph{GfxRenderer::BeginRendering} method, and then the current render target must be set and cleared. After everything is drawn the \emph{GfxRenderer\-::Finalize\-Render\-Target} method must be called and then another render target is set or the whole rendering is finished by the \emph{GfxRenderer::EndRendering} method.

An important attribute of the \emph{GfxSystem::GfxRenderer} class is the point\-er to the \emph{GfxSystem::SceneMgr} class created on its initialization accessible by the \emph{GfxRenderer::GetSceneManager} method. This is the class to which all drawable components (sprites, models) must be registered along with a \emph{Transform} component of their entity by the \emph{SceneMgr::AddDrawable} method so then they are rendered by the \emph{SceneMgr::DrawVisibleDrawables} method if they are visible.

To provide debug drawing of physics entities the \emph{GfxSystem::PhysicsDraw} proxy class was defined and registered as an implementation of the \emph{b2\-Debug\-Draw} class from the Box2D library. All methods are redirected to corresponding methods in the \emph{GfxSystem::GfxRenderer} class.

\section{Application window}

The graphic system also manages creating and handling the application window, which depends on the used operating system. This functionality is implemented by the \emph{GfxSystem::GfxWindow} class with the usage of the SDL library. This class has methods for getting and setting a window position, size and title or a visibility of a mouse cursor, toggling a fullscreen mode and handling system window events. It is also possible to register a screen listener represented by a class implementing the \emph{GfxSystem::IGfxWindowListener} interface. This class will be informed when the screen resolution is changed.

Note that the SDL library also provides features in low-level audio and input management but since audio is not yet implemented and input management is done by more specialized library, the only used SDL features are the window management and creating the rendering context.

\section{Mesh and texture}

Meshes and textures are essential parts of the \emph{Model} and \emph{Sprite} components. They can be loaded via the \emph{GfxSystem::Mesh} and \emph{GfxSystem::Texture} classes that inherit from the \emph{ResourceSystem::Resource} class (for more information see chapter about the resource system).

On loading of a texture resource the \emph{GfxRenderer::LoadTexture} abstract method is called. For OpenGL implementation, the SOIL library is used, which is a tiny C library used for uploading common texture formats into the OpenGL.

For defining meshes, the Wavefront OBJ file format \cite{obj} is used with content of all material files (.mtl extension) at the beginning of the file with the .model extension. Every texture used in the model definition is automatically loaded as a resource.
 
\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Viewport] -- a region of the application window where entities are rendered to
  \item[Render target] -- a pair or a viewport and a camera
  \item[Sprite] -- a component for showing an entity as an image (even animated or transparent)
  \item[Model] -- a component for showing an entity as a 3D-model
  \item[Texture] -- a bitmap image applied to a surface of a graphic object
  \item[Mesh] -- a collection of vertices, edges and faces that defines the shape of a polyhedral object
\end{description}


\chapter{GUI system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{GUISystemClassDiagram.pdf}
	\caption{Class diagram of the GUI system namespace}
	\label{fig:guisystem-diagram}
\end{figure}

The GUI system provides creating and drawing a graphic user interface based on the CEGUI library for the editor and the game itself. It also manages a user interaction with GUI elements, element layouts, viewports and GUI console.

\section{GUI manager}

The main class of the GUI system is the \emph{GUISystem::GUIMgr}, which is a connector for drawing, input handling and resource and script providing between the CEGUI library and the engine. During its creation it creates a CEGUI renderer, connects the resource manager with the CEGUI system via the \emph{GUISystem::Resource\-Provider} class (see section \ref{sec:gui-resources}), connects the script manager with the CEGUI system via the \emph{GUISystem::ScriptProvider} class (see section \ref{sec:gui-script}), provides itself as an input and screen listener and creates the GUI console, which is then accessible via the \emph{GUIMgr::GetConsole} method (see section \ref{sec:gui-console}). On its initialization (\emph{GUIMgr::Init}) it loads necessary GUI resources (schemes, image sets, fonts, layouts and looknfeels) and creates a root window.

For loading a root layout from a file, the method \emph{GUIMgr::LoadRootLayout} is provided with only one parameter specifying a name of a file where a layout is defined. This method calls the \emph{GUIMgr::LoadWindowLayout}, which is a common method for loading a window layout from a file that also provides a translation of all texts via the string manager. There are also methods for unloading and getting the current root layout. For more information about layouts see section \ref{sec:gui-layouts}.

There are two methods called in the application main loop. First the \emph{GUIMgr::Update} updates time of the GUI system, and then the \emph{GUIMgr::\-Render\-GUI} draws the whole GUI. There are several input callback methods that converts an OIS library representation of keyboard and mouse events to a CEGUI one and forwards them to the CEGUI library. It is possible to get the currently processing input event by the \emph{GUIMgr::GetCurrentInputEvent} method. There is also a callback method for a resolution change that forwards this information to the CEGUI library too.

\section{GUI resources}
\label{sec:gui-resources}

A GUI resource is represented by the \emph{GUISystem::CEGUIResource} class. Since the CEGUI library is not designed to allow an automatic resource unloading and reloading on demand this class only loads raw data by the resource manager and after providing them to the CEGUI library by the \emph{CEGUIResource::GetResource} method, it unloads them.

When the CEGUI library needs a resource, it calls an appropriate method of a resource provider class provided on an initialization of the library. In this engine it is the \emph{GUISystem::ResourceProvider} class and its method \emph{ResourceProvider::loadRawDataContainer} that gets the resource from the resource manager and forwards its data to the library. In the figure \ref{fig:load-layout-sequence} there is an example of loading a GUI layout of the \emph{GUISystem::MessageBox} class.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{LoadLayoutSequence.pdf}
	\caption{An example of loading a GUI layout}
	\label{fig:load-layout-sequence}
\end{figure}

\section{Script provider}
\label{sec:gui-script}

For a connection of the CEGUI library and the script system the \emph{GUISystem::ScriptProvider} class is introduced implementing the \emph{CEGUI::Script\-Module} interface. The only method from this interface that truly needs an implementation is the \emph{ScriptModule::subscribeEvent}, which provides a name of event, a name of function that should handle it and an object to which the name of event and an object with a callback method should be subscribed.

This transformation is implemented by the \emph{GUISystem::ScriptCallback} class that stores the function name given in its constructor and which calls an appropriate script function as a callback. It calls a function from the script module associated with the GUI layout component of the layout, which gets the event or a function from the \verb/GuiCallback.as/ module as a default. For more information see the User Guide document.
%todo the User Guide document???

\section{Layouts}
\label{sec:gui-layouts}

A GUI layout defines a composition of GUI elements including their properties such as position, size and content and their behavior. Their properties can be defined in an external XML file, but more dynamic compositions need also a lot of a code support, their behavior can be defined in an external script file, but more complicated reactions have to be also native coded.

As an example that can be used both in the editor and in the game, the \emph{GUISystem::MessageBox} class was created, which provides a modal dialog for informing the user or for asking the user a question and receiving the answer. The basic layout with all possible buttons is specified in an XML file, which is loaded in a class constructor, where these buttons are mapped to the correspondent objects and displayed according to a message box type. Setting of a message text (\emph{MessageBox::SetText}) also changes a static text GUI element specified in an XML file. The behavior after the user clicks to one of buttons is defined by a callback function that can be registered by the \emph{MessageBox::RegisterCallback} method and that gets the kind of the chosen button and the ID specified in a constructor parameter. For an easier usage there is the global function \emph{GUISystem::ShowMessageBox} that takes all necessary parameters (a text, a kind of a message box, a callback and an ID) and creates and shows an appropriate message box. A similar concept has the \emph{GUISystem::PromptBox} class providing a modal dialog that asks for a text input from the user and the \emph{GUISystem::FolderSelector} class providing a modal dialog for selecting a folder.

Another example is the \emph{GUISystem::VerticalLayout} class that helps to keep GUI elements positioned in a vertical layout and automatically repositions them when one of them changes its size. In its constructor, the container in which all child elements should be managed is specified, and then the \emph{VerticalLayout::AddChildWindow} method is used for adding them. It is also possible to set spacing between them, and there is a method for updating a layout. It is obvious that this layout is defined without any XML file. For more information about creating own layouts see the User Guide document.
%todo the User Guide document???

\section{Viewports}

The \emph{GUISystem::ViewportWindow} class represents a viewport window with a frame, where a scene is rendered by the graphic system. For defining a position, an angle and a zoom of a view of a scene that will be displayed in the viewport a camera in form of an entity with a camera component must be set by the \emph{ViewportWindow::SetCamera} method. It is possible to define whether the viewport allows a direct edit of a view and displayed entities by the \emph{ViewportWindow::SetMovableContent} method. For example in the editor, there are two viewports -- in the bottom one, the scene can be edited whereas in the top one the result is only shown. The method \emph{ViewportWindow::AddInputListener} registers the input listener so any class can react to mouse and keyboard actions done in the viewport when it has been activated by the method \emph{ViewportWindow::Activate}.

\section{Popup menus}

The \emph{GUISystem::PopupMgr} class provides methods creating (\emph{Popup\-Mgr\-::\-Create\-Popup\-Menu} / \emph{PopupMgr::CreateMenuItem}) and destroying (\emph{PopupMgr::DestroyPopupMenu} / \emph{PopupMgr::DestroyMenuItem}) popup menu and its items as well as showing (\emph{PopupMgr::ShowPopup}) and hiding (\emph{PopupMgr::HidePopup}) it and it also cares about calling a proper callback when a menu item is clicked on. The callback method is provided to the manager, when the popup menu is being opened by the \emph{PopupMgr::ShowPopup} method.

\section{GUI console}
\label{sec:gui-console}

The \emph{GUISystem::GUIConsole} class manages the console, which is accessible both in the game and in the editor. The console receives all messages from the log system via the method \emph{GUIConsole::AppendLogMessage} and shows those that have an equal or higher level than the one previously set by the \emph{GUIConsole::SetLogLevelTreshold} method. In addition, the user can type commands to the console prompt line, which are sent to the script system as a body of a method without parameters that is immediately built and run and if there is a call of the \verb/Print/ function its content will be printed to the console via the \emph{GUIConsole::AppendScriptMessage} method. For better usage of the console a history of previously typed commands is stored and can be revealed by up and down arrows. The console can be shown or hidden by the \emph{GUIConsole::ToggleConsole} method.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[GUI] -- a graphic user interface
  \item[GUI element] -- an element from which the whole GUI is created such as label, edit box, list etc.
  \item[Layout] -- a composition of GUI elements including definition of their properties and behavior
  \item[Viewport] -- a GUI element where a scene can be rendered by the graphic system
  \item[GUI console] -- a window where log and script messages immediately appears and which allows an input of script commands
  \item[GUI event] -- a significant situation made by the user input such as a mouse click or a keyboard press
  \item[Callback] -- a function or method that is called as a reaction to a GUI event
  \item[Scheme] -- a definition of connections between a physical window type and a window look
\end{description}

\chapter{Editor}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EditorClassDiagram.pdf}
	\caption{Class diagram of the Editor namespace}
	\label{fig:editor-diagram}
\end{figure}

The editor is used for an easy creation of a new game based on this engine. It provides a well-arranged graphic user interface for managing everything from the whole project to each entity in several scenes. The main advantage is that every change made to a scene is immediately visible in the game window, where the game action can be started anytime.

\section{Editor managers}

The \emph{Editor::EditorMgr} class manages the logical part of the editor and it owns an instance of the \emph{Editor::EditorGUI} class that focuses to the GUI of the editor. Both of them have methods called at the loading and the unloading of the editor and also methods for updating logic and drawing in the application loop.

The first mentioned class has methods for managing projects, scene and entities. It manages selecting entities and editing the current one, it reacts on choosing all items in the main menu such as creating a new entity, duplicating and deleting current or selected entities, adding and removing entity components, creating a prototype from a current entity, creating or loading a project or a scene and it solves changing an entity name or an entity property. It also provides a function for all edit tools such as moving, rotating or scaling of a chosen entity and for resuming, pausing and restarting the game action. Finally, there are methods for getting a reference to all editor windows and for updating them.

The second class compounds all editor layouts such as the game and editor viewports, the resource, prototype and layer windows and the editor menu and initializes and updates them. It directly updates the entity editor window according to the current entity that uses the vertical layout for positioning entity components and various value editors for showing and editing all kinds of entity properties such as strings, vectors, resources and arrays.

\section{Used layouts}

There are six layout classes for editor components. All of them have initialization and update methods and callbacks for significant events and load their look from an external XML file and introduce the reactions on events and loading data from the application. The \emph{Editor::Create\-Project\-Dialog} represents the dialog for creating a new project, the \emph{Editor\-::\-Hierarchy\-Window} manages the hierarchy of entities, the \emph{Editor\-::\-Layer\-Window} manages the layers the entities are put to, the \emph{Editor\-::\-Prototype\-Window} manages the prototypes of entities, the \emph{Editor\-::\-Entity\-Window} manages components and properties of entities and the \emph{Editor\-::\-Resource\-Window} manages the resources that the entities can use.

\section{Value editors}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.8\textwidth]{EditorValueEditorsClassDiagram.pdf}
	\caption{Class diagram of editor value editors}
	\label{fig:editor-value-editors-diagram}
\end{figure}

All value editors derive from the \emph{Editor::AbstractValueEditor} base class (see the figure \ref{fig:editor-value-editors-diagram}). This class has three abstract methods that every value editor must implement and some methods that can help with the implementation. The first is the \emph{AbstractValueEditor::CreateWidget} method with the parameter representing a string that should be used as a prefix for a name of every created component. This method should create a widget for editing a required kind of value and return it. The second is the \emph{AbstractValueEditor::Update} method which is called when the current value of the property should be displayed in the value editor and the last is the \emph{AbstractValueEditor::Submit} method which is called when the value of the property should be updated by the user input to the value editor. In the figure \ref{fig:editor-value-sequence} there is an example how calling the last two methods is proceeded.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{EditorValueSequence.pdf}
	\caption[Sequence diagram of getting and setting property value]{Sequence diagram of getting and setting property value in the editor (the boolean property \emph{Visible} of the \emph{GUILayout} component is used as an example)}
	\label{fig:editor-value-sequence}
\end{figure}

For an easier implementation of value editors the model classes with the \emph{Editor::IValueEditorModel} class as the base class were created. From the accessors of this class value editors should get the name and tool-tip for the edited property, whether the property is valid, read only, an element of a list, removable, shareable, shared and also they should be able to remove the property or set whether it is shared if is possible. It is recommended to derive own models from the \emph{Editor::ITypedValueEditor\-Model$<$T$>$} template class that also defines the getter and setter for the value of the edited property.

For example the \emph{Editor::StringEditor} class derives directly from the \emph{Editor::AbstractValueEditor} class and implements a simple editor for properties which values are easily convertible from and to string which contains a label with a property name, an edit box for displaying and editing the value and a remove button if the property is removable (i.e. as a part of an array). It uses a model derived from the \emph{Editor::ITypedValueEditorModel$<$string$>$} class to create a widget, update and submit the value which is specified in the constructor parameter. A useful implementation of this model is the \emph{Editor::StringPropertyModel} class that operates with the \emph{Reflection::Property\-Holder} class from which it gets all necessary information and which it can modify with a new value.

There are another examples of value editors and its models in the code that can help with a creation of further ones such as editors for arrays, resources etc.

\chapter{Input system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{InputSystemClassDiagram.pdf}
	\caption{Class diagram of the Input system namespace}
	\label{fig:inputsystem-diagram}
\end{figure}

Since every game must somehow react to the input from the player, the input system, which handles keyboard and mouse events and forwards them to other systems, was implemented.

\section{Input manager}
The needs of games are different, but the ways they want to access the input devices are still the same. Either they want to receive a notification when something interesting happens or they want to poll the device for its current state. The \emph{InputSystem::InputMgr} class implements both of these approaches.

The first one is provided via the \emph{InputSystem::IInputListener} interface, which should be implemented and then registered by using the \emph{InputMgr::\-AddInputListener} method for receiving the notification in callbacks of the interface.

The second approach is supported by multiple methods for querying the device state. The \emph{InputMgr::IsKeyDown} method returns whether any specific key is currently held down, while the \emph{InputMgr::IsMouseButtonPressed} method does the same with the currently pressed mouse button. Finally, the \emph{InputMgr::GetMouseState} returns a whole bunch of mouse related information such as a cursor and wheel position or pressed buttons.

To keep things synchronized, the event processing is executed in the main game thread. At the beginning of the application main loop, the \emph{InputMgr::CaptureInput} method is called, where the events are recognized and then distributed to the listeners.

The \emph{InputSystem::InputMgr} class is only a proxy class that calls methods of the implementation specific class \emph{InputSystem::OISListener}, which implements the \emph{OIS::MouseListener} and \emph{OIS::KeyListener} interfaces from the OIS library used for the platform independent input management.


\chapter{Log system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{LogSystemClassDiagram.pdf}
	\caption{Class diagram of the Log system namespace}
	\label{fig:logsystem-diagram}
\end{figure}

The log system manages internal log messages that are used for providing informations about application processes. It is useful for debugging the project. These messages can have various levels of a severity (from trace and debug messages to errors) and it is possible to set the minimal level of messages to show (i.e. only warning and errors). Another function of the log system is managing a real-time in-game profiling, useful for a location of the most time critical parts of the project that can leads to effective optimization.

\section{Logging messages}
\label{sec:logging}

The main class responsible for logging messages is the \emph{LogSystem::LogMgr}. At the application start it is initialized with a name of the file to which the messages are also written. There is only one method that logs a message of a certain severity to the file and consoles if exist. This method should not be used directly but via the class \emph{LogSystem::Logger}.

The lifetime of the \emph{Logger} should be only one code statement and it represents one message. In the constructor, the level of the message and whether to generate a stack trace are specified. Then a sequence of the operator $<<$ is used to build the message from strings, numbers and other common types (any user type can be supported by specifying an own operator $<<$ overloading). At the end of the statement, the destructor is automatically called (if the instance is not assigned to a variable).

For an even easier logging, macros are defined for every supported level of severity, adding the information about the file and the line, where it is logged from in case of error or warning message. Thanks to macros, it is possible to define the minimum level of severity that should be logged at the compile time, so the messages with a lower level are even not compiled to the final program, which saves time and memory. In the table \ref{tab:log-macros}, there are the macros associated with the levels of severity.

\begin{table}[htbp]
	\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			Macro & Level & Stack trace & Additional info \\
			\hline
			ocError & error & yes & yes \\
			ocWarning & warning & no & yes \\
			ocInfo & information & no & no \\
			ocDebug & debug & no & no \\
			ocTrace & trace & no & no \\
			\hline
		\end{tabular}
	\caption[Definitions of log macros]{Definitions of log macros from the most severe to the least ones}
	\label{tab:log-macros}
\end{table}

If it is for example necessary to inform that the entity (of which the handle is available) is created, the following statement should be written anywhere in the code: \verb/ocInfo << handle << " was created.";/. When the process passed this code and the minimum level of messages to log is lower than the information one, then for example, the following message will be generated: \verb/13:05:18: Entity(25) was created./

\section{Profiling functions}
\label{sec:profiling}

The profiling of a block of a code or a whole function is really easy. First the \verb/USE_PROFILER/ preprocessor directive must be globally defined, the class \emph{LogSystem::Profiler} must be initialized at the start of the application and its method \emph{Update} must be called in each application loop.

Then anywhere in a code the \verb/PROFILE(name)/ macro can be typed where the parameter \verb/name/ is used for identification of the corresponding results (the abbreviation \verb/PROFILE_FNC()/ uses the current function name). From that line the profiler will start measuring time and it will stop at the end of the current block or function.

Finally, when the application runs a call of \emph{Profiler}'s method \emph{Start} (which can be invoked with a keyboard shortcut \emph{CTRL+F5}), the profiling is activated and a call of its methods \emph{Stop} and \emph{DumpIntoConsole} (another press of \emph{CTRL+F5}) deactivates it and writes results to the text console. In addition, it is possible to ask whether the profiler is active via the method \emph{IsRunning}.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Log message] -- a text describing a specific action or an application state occurred at a certain time with a defined severity
  \item[Level of severity] -- an importance of a message to the application process
  \item[Stack trace] -- a list of functions that the current statement is called from right now
  \item[Logging] -- tracking the code execution by writing log messages to a console and a file
  \item[Console] -- a window where log messages immediately appear
  \item[Profiling] -- measuring a real time of execution of a specific code
\end{description}



\chapter{Resource system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ResourceSystemClassDiagram.pdf}
	\caption{Class diagram of the Resource system namespace}
	\label{fig:resourcesystem-diagram}
\end{figure}

Every game needs to load packs of data from external devices such as a hard drive or network. The data come in blocks belonging together and representing a unit of something usually called \emph{resource}. Since the games work with loads of resources it is necessary to organize them both in-game and on the disk. Also, the data loaded are usually quite large and it's necessary to free them when possible to save memory. All of these tasks are implemented in the resource system as well as loading and saving scenes.

\section{Resources}

The resource is a group of data belonging together. In the engine this is represented by the abstract \emph{ResourceSystem::Resource} class. It contains all basic attributes of a resource and allows its users to load or unload it, but the actual implementation depends on the specific type of the resource. For example, an XML file is loaded and parsed in a different way then an OpenGL texture. However, for the user it is never really necessary to know what type of the resource he is working with, so using this class as an abstraction is enough. Only the endpoint subsystem needs to work with the specific type to be able to grab the parsed data out of it. For example, the texture resource can be carried around the system as a common \emph{ResourceSystem::Resource} class until it reaches the graphical subsystem, which converts it to the texture resource and grabs the implementation specific texture data out of it.

\subsection{Resource states}

Each resource can be in one of the states described in the figure \ref{fig:resource-states} at the given point of time:

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ResourceStates.pdf}
	\caption[Possible resource states]{Possible resource states and their description}
	\label{fig:resource-states}
\end{figure}

\subsection{Content of the resource}

Once the data for the resource are loaded, it must be parsed into the desired format. This can mean a data structure stored directly inside the resource class or just a handle to the data stored in other parts of the system. However, both of these must exist only in single instance in the whole system -- in the resource which parsed the data. Otherwise the data could become desynchronized. If the resource was unloaded, a pointer to its data could still exist somewhere. 

For example, the XML resource creates a tree structure for the parsed data and allows its users to traverse the tree. But nowhere in the system a pointer to the same tree or any of its parts exists. Another example is a texture. After it loads data, they are passed into the graphical subsystem, which creates a platform specific texture out of it and returns only a texture handle. This handle is then stored only in the resource.

\subsection{Resource pointers}

Since the resources are passed all around the game system, we must somehow prevent any memory leaks from appearing. Doing so is quite easy however -- we simply use the shared pointer mechanism. It points to the common abstract resource (the \emph{ResourceSystem::ResourcePtr} class) and to specific resources as well (the \emph{ScriptSystem::ScriptResourcePtr} or the \emph{ResourceSystem::XMLResourcePtr} classes for example). The abstract resource pointer can be automatically converted to any specific resource pointer, but if the type does not match, an assertion fault will be raised to prevent a memory corruption. All resource pointers are defined in the \verb'Utils/ResourcePointers.h' file.

For defining a new resource type, see the Extending Ocerus document. In the table \ref{tab:resource-types} there are all currently existing types of resources with a brief description.

\begin{table}[htbp]
	\centering
		%{\scriptsize 
		\begin{tabular}{|p{0.20\hsize}|p{0.73\hsize}|}
			\hline
			Resource type & Description and supported extensions\\
			\hline
			Texture & a bitmap picture (jpg, png, bmp, psd, dds, hdr, tga)\\
			Mesh & a 3D object (model)\\
			CEGUI & a GUI related resource (layout, scheme, font, imageset, looknfeel, ttf)\\
			Text & a text in a specific language (str)\\
			XML & an XML document (xml)\\
			Script & a file with AngelScript script functions (as)\\
			\hline
		\end{tabular}
		%}
	\caption[List of defined resource types]{List of defined resource types with a brief description}
	\label{tab:resource-types}
\end{table}

\section{Resource manager}

The resource manager represented by the \emph{ResourceSystem::ResourceMgr} class takes care of organizing resources into groups and providing an interface to other parts of the system to control or grab the resources. Coupling resources into groups makes it easier to load or unload a whole bunch of them. There are methods for adding one file or a whole directory to a resource group or for getting a resource pointer to a resource of a specific name from a specific group.

To make game development easier, the source of each resource is automatically checked for an update. If it has changed, the resource is automatically reloaded if it was previously loaded. So, for example, if the user changes a currently loaded texture in an image editor and saves it, it will be immediately updated in the game.

Since gaming systems have limited memory it is possible to limit the memory used by resources. Resources usually take the biggest chunk of memory, so when lowering the memory usage it is best to start here. Hopefully, the resource manager allows defining a limit which it will try to keep. When the memory is running out, it will attempt to unload resources that were not used for a long time. These resources will remain in the system and will be ready to be loaded as soon as they are needed. However, there are certain circumstances under which the resources must not be unloaded. An example of such is rendering -- no texture can be unloaded until the frame is ready. For this reason the unloading can be temporarily disabled.

If it is necessary to track the resource loading progress (for example when a scene is loading), there is the \emph{ResourceSystem::IResourceLoadingListener} interface that should be implemented and registered by the \emph{ResourceMgr\-::\-Set\-Loading\-Listener} method. Its methods are called when the loading of one resource or a resource group starts and ends.

\section{Loading and saving scenes}

For storing a state of a scene from the editor or from the game itself to a file, an XML format is used. There are two classes that help with saving data to a file and loading them back.

The \emph{ResourceSystem::XMLOutput} class provides a formatted XML output to a file. First when the instance is created, a file specified in a constructor parameter is opened. Then some methods for writing XML elements and attributes are used. Finally the file is closed in the destructor or in the method \emph{XMLOutput::CloseAndReport}. For example the file named \verb/file.xml/ with the XML structure

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<name key="value">
  <element>text</element>
</name>
\end{verbatim}

\noindent is created by calling this sequence of orders:

\begin{verbatim}
ResourceSystem::XMLOutput out("file.xml"); // writes header
out.BeginElementStart("name"); // writes <name
out.AddAttribute("key", "value"); // writes key="value"
out.BeginElementFinish(); // writes >
out.BeginElement("element"); // writes <element>
out.WriteString("text"); // writes text
out.EndElement(); // writes </element>
// destructor automatically closes all open elements
\end{verbatim}

\noindent As the example shows the class does an indent, remembers names of open elements and automatically closes all open elements in the end.

The \emph{ResourceSystem::XMLResource} class on the other hand loads an XML file and iterates over its elements and attributes. Since this class derives from the \emph{ResourceSystem::Resource} class first a resource pointer to the file must be get by \emph{ResourceMgr::GetResource} method and retyped to the \emph{ResourceSystem::XMLResourcePtr}. Then the top level elements can be iterated by the \emph{XMLResource::IterateTopLevel} method, which returns \emph{ResourceSystem::XMLNodeIterator} class, which serves as an iterator and which should be compared with a result of the \emph{XMLResource::EndTopLevel} method for a detection of the end of top level elements. The iterator class has analogical methods (\emph{XMLNodeIterator::IterateChildren} and \emph{XMLNodeIterator::EndChildren}) for iteration over children of the element it represents. Beside them it has also methods for getting an element's value, a value of its child or of its specific attribute. Since these methods are templates every value can be converted from a string to any chosen data type.

\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Resource] -- a unit of data usually stored in an external device the game will be working with as a whole
  \item[Resource pointer] -- a shared pointer to a resource that can be used in the whole engine
  \item[Resource type] -- resources with a common type are loaded in the same way, i.e. textures, models, scripts, texts\ldots
  \item[XML] -- Extensible Markup Language (XML) is a set of rules for encoding documents in machine-readable form
\end{description}


\chapter{Script system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ScriptSystemClassDiagram.pdf}
	\caption{Class diagram of the Script system}
	\label{fig:scriptsystem-diagram}
\end{figure}

The script system allows customizing reactions to application events such as messages sent to entities or GUI interactions without a compilation of a whole application to the users of the engine. The advantage of using scripts is an easier extension of the application which can be done even by non-professional users because in the script environment they cannot do any fatal errors that can corrupt the application and it is possible to have a full control of the script execution -- for example timeout of execution prevents cycling. The disadvantage is a slower execution of scripts than a native code so a user should decide which part of system will be native coded and which can be done by scripts.

\section{Interface of the script manager}

The script manager is represented by the class \emph{ScriptSystem::ScriptMgr} that encapsulates the script engine and manages an access to the script modules. This class is a singleton and it is created when the game starts. It initializes the AngelScript engine and registers all integral classes and functions (see the Script Reference documentation) as well as all user-defined ones.

The first thing a caller of a script function must do is to obtain a function ID. It can be get from the method \emph{ScriptMgr::GetFunctionID} that needs the name of the module where the function is and its declaration. For example if the name of function to be called is \verb/IncreaseArgument/ and it receives one integer argument and returns also an integer, the declaration of it will be \verb/int32 IncreaseArgument(int32)/. This method returns an integer that means the desired function ID (greater than or equal to zero) or the error code (less than zero) which means the function with this declaration could not be find in the mentioned module or this module does not exist or cannot be built from sources (see log for further information). The function ID is valid all time the module exists in memory so it can be stored for later usage.

The function mentioned above calls \emph{ScriptMgr::GetModule} to obtain desired module. This method returns the module from a memory or loads its sources from a disc and builds it if necessary. If it is inconvenient that the module is built at the first call of its function, this method can be called before to get a confidence that the module is ready to use.

The calling of script functions can be done with three methods. First the caller calls the \emph{ScriptMgr::PrepareContext} which needs the function ID and returns context prepared for passing the argument values. Then the argument values can be passed with the \emph{SetFunctionArgument} method which needs the prepared context as the first argument, a parameter index as the second one and a parameter value in form of the \emph{PropertyFunctionParameter} as the last one. After that the \emph{ScriptMgr::ExecuteContext} should be called with the prepared context as the first argument and a maximum time of executing script in milliseconds (0 means infinity) to prevent cycling as the second one. This method executes the script with given arguments and returns whether the execution was successful. If so it is possible to get a return value of function with corresponding methods of context. In the end the context should be released to avoid memory leaks.

There is a possibility to call a simple script string stored in a memory by the method \emph{ScriptMgr::ExecuteString} which accepts this string as the first parameter. The method wraps it to the function without parameters and builds it and calls it as a part of the module specified in the second optional parameter so it is possible to declare local variables and to call functions from the module. This is useful for example for implementing a user console.

As mentioned in the User Guide document
%todo check it
it is possible to use a conditional compilation of scripts. The method \emph{ScriptMgr::DefineWord} adds a preprocessor define passed as the string argument. The \emph{ScriptMgr::\-Unload\-Module} and \emph{ScriptMgr::ClearModules} methods unload one/all previously loaded and built modules. All function IDs and contexts associated with these modules will be superseded so the caller should inform all objects that holds them about it (use \emph{ResourceUnloadCallback} in ScriptRegister.cpp for specify actions done when modules are unloaded). These methods could be called when it is needed to reload modules or free all memory used by them but when it is better not to destroy the whole script engine.

There are also two methods for getting time. The first one (\emph{ScriptMgr::GetGameTime}) returns the game time which does not increase when the game action is paused, whereas the second one (\emph{ScriptMgr::\-Get\-Global\-Time}) returns the engine time which does it.

\section{The Script component}
\label{sec:script-component}

The purpose of the Script component is to provide a possibility for an entity to respond to a received message by a script. When the message is received it should find an appropriate handler, which is a script function with a strict declaration (see EntityMessageTypes.h for entity message handler declarations), in defined modules and call it with the arguments provided in the message data.

The component has five registered properties. The first one is an array of module files that are searched for message handlers; the second represents the maximum script execution time in milliseconds after that the script will be aborted. For better performance this component caches function IDs founded in modules in a map so it is necessary to inform it when the modules are going to change by sending a message \verb/RESOURCE_UPDATE/ to its entity.

The last three properties provide a support for scripts that should be called periodically and that should remember their state. These scripts are written to the \verb/void OnAction()/ message handlers which are called when the message \verb/CHECK_ACTION/ is received (which should be every game loop) and when the appropriate time in the \verb/ScriptTimes/ property is lower than the current game time. From these scripts it is possible to call the \verb/int32 GetState()/ function which returns the appropriate state from the \verb/ScriptStates/ property and to call the \verb/void SetAndSleep(int32, uint64)/ function which sets this state and sets the time to the current game time plus the second argument in milliseconds. The right time and state are got thanks to the \verb/ScriptCurrentArrayIndex/ property.

The most important method of this component is the \emph{Script::Handle\-Me\-ssa\-ge} that accepts a message structure as parameter and returns if the message was processed well or it was ignored. First it checks whether the function IDs should be updated and if the message is \verb/RESOURCE_UPDATE/ it ensures to do an update before the next message processing. Then it gets an appropriate function ID depended on a message type, checks whether to continue in case of the \verb/CHECK_ACTION/ message and calls the script manager to prepare a new context with this function. After that the pointer to the parent entity is stored to the context data so the \verb/this/ property can be called from a script to get the current entity handle. Then it adds additional parameters to a function call from the message data according to the message type and executes the context with defined timeout. Finally it releases the context and returns whether the execution was successful. An example of a reaction to a message is shown in the figure \ref{fig:scriptsystem-callback}.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{ScriptCallbackSequence.pdf}
	\caption{An example of reaction of the Script component to a message}
	\label{fig:scriptsystem-callback}
\end{figure}

\section{Glossary}

This is a glossary of the most used terms in the previous sections:

\begin{description}
	\item[Script function] -- a function defined and implemented in a script file
	\item[Script file] -- one file containing script class and script function definitions, can include a code from other files
	\item[Script module] -- one or more script files connected by include directives, which are managed and built together and have a common namespace
	\item[Function ID] -- an identification of a script function based on a module name and a function declaration
	\item[Script context] -- an object that wraps script function calling, it must be prepared with a function ID, executed and released, function arguments can be passed and a return value can be obtained
	\item[Script engine] -- an object that registers C++ classes, global functions, properties etc. for usage in a script code and manages script modules and contexts
	\item[Script manager] -- a class that encapsulated a script engine and provides methods for managing script modules and calling script functions
	\item[Script component] -- a component that provides script callbacks to the messages for an entity
\end{description}


\chapter{String system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{StringSystemClassDiagram.pdf}
	\caption{Class diagram of the String system namespace}
	\label{fig:stringsystem-diagram}
\end{figure}

The string system manages all texts that are visible to the user except internal log messages. It supports localization to various languages and their country-specific dialects and a switching among them on fly.

\section{Interface of the string manager}

The string manager is represented by the class \emph{StringSystem::StringMgr} that provides all necessary services. There are two instances of this class when the application runs. The first one manages system texts (i.e. labels in editor, common error messages etc.), the second one provides an access to project specific texts, so they differs only in a path to the root directory where the text resources are loaded from. Both are initialized when the application starts and destroyed on an application shutdown. The class provides static methods returning these instances or it is possible to use defined macros.

The first method that is necessary to call before using the others is the \emph{StringMgr::LoadLanguagePack} that expects the language and the country code (both can be omitted) which meaning is widely explained in the User Guide documentation.
%todo check whether this directory layout is described in User Guide documentation
It removes old text items and loads new ones according to a specific language setting to the memory via the \emph{StringMgr::\-Text\-Resource} class and divides them to the desired groups. This method can be called at any time during the whole execution of application but the other systems must refresh their data themselves. The accepted format of text files and necessary directory layout for loading them are described in the User Guide documentation.

There are several methods in the class for getting the text data according to its group name and key which differs in returning a pointer to the data or the data itself and in specifying or omitting the group name (using the default one instead). If the text data of a specified group name and key does not exist, an empty string is returned and an error message is written to the log.

\section{Using a variable text}
\label{sec:text-format}

If the loaded text data contains character sequences in a form of \verb/%x/ (\verb/x/ is a number from 1 to 9) it is possible to replace them by another text using the class \emph{StringSystem::TextFormat}. Just construct the instance of this class with the loaded text as a parameter, then use a sequence of \verb/<</ operators to replace all well formatted character sequences and store it to another text data variable.

The \verb/<</ operator finds the described character sequence with the minimum number and replaces it with the text provided as the parameter. If no such sequence is found then it inserts the provided text at the end of the loaded text. For example if the code

\begin{verbatim}
StringSystem::TextData loaded = "The %2, the %3 and the %1.";
StringSystem::TextData result = StringSystem::TextFormat
    (loaded) << "third" << "first" << "second";
\end{verbatim}

\noindent is called then in the \verb/result/ variable there will be the following text:

\begin{verbatim}
The first, the second and the third.
\end{verbatim}


\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[Key] -- an ID that is used for indexing a text data, must be unique within a group
  \item[Text item] -- a pair of a key and a text data that is contained it a text file
  \item[Group] -- a set of text items that can be indexed from application, one file contains text items from one group, text items from one group can be contained in several files
  \item[Language code] -- two-character acronym representing a world language according to ISO 639-1 \cite{ISO-639-1}.
  \item[Country code] -- two-character acronym representing a country according to ISO 3166-1 alpha-2 \cite{ISO-3166-1}.
\end{description}



\chapter{Memory system}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1\textwidth]{MemoryClassDiagram.pdf}
	\caption{Class diagram of the Memory namespace}
	\label{fig:memory-diagram}
\end{figure}

The memory system controls the memory allocation of the whole application. It attempts to work under the hood, so that the rest of the project does not need to know about that. It provides tools to override the default dynamic memory allocation as well as custom specialized allocators for small objects or containers.

Since games are very different from other applications they also have specific memory requirements. However, the default managers in current compilers are targeted to common programs. The game is a real-time per\-for\-man\-ce-in\-ten\-si\-ve application while it also allocates and deallocates a lot of objects on a regular basis. An example of this might be graphical effects spawned and destroyed during the play to keep the action high. In this case it is much more efficient to pool the objects instead of allocating them on the general heap. Another problem arises on game consoles where the memory available to the game is very limited and the engine must hold a tight control on the state of the memory and dynamically clean it if necessary while the action is still running.

\section{Global allocation}
The main part of this system are overridden default memory allocation functions of the compiler. The memory subsystem provides alternatives to the \emph{malloc} and \emph{free} functions called the \emph{Memory::CustomMalloc} and \emph{Memory\-::\-Custom\-Free}. The \emph{new} and \emph{delete} operators are overridden automatically, so it is not necessary using the functions manually. Note that all this works in the whole application as well as in the libraries.

\section{Free lists}
The \emph{Memory::FreeList} is a template implementation of a memory pool allocator. Its configuration is done by specifying the policies as template arguments. The \emph{Memory::FreeList} then provides methods for allocation (\emph{Allocate}) and deallocation (\emph{Free)}. From the user's point of view they work the same way as \emph{new} and \emph{delete} while even the constructor/destructor is called if required by the construction policy.

The allocation policy defines the structure of the pool in the memory. This may also influence the performance depending on the character of allocations/deallocations. The construction policy enables or disables the use of constructors/destructors while allocating/deallocating an object. The growth policy defines the way the memory pool is enlarged or shrink when needed. This can also influence the performance and memory consumption.

\section{Stl pool allocator}
The \emph{Memory::StlPoolAllocator} is a templatized STL-compliant pooled allocator. It is implemented as a wrapper on the top of \emph{Memory::FreeList} with parameters suitable for STL containers. The allocator is completely ready to be directly used with the containers by supplying it as a template parameter into them. In the engine this is done in the \emph{Containers.h} file. The pooled containers are named \emph{pooled\_list}, \emph{pooled\_set}, etc.

\section{Class allocation}
As mentioned before it is common in games to rapidly allocate and deallocate objects of the same type -- a graphical effect might be an example. At the same time the programmer might not want to store the objects in a structure suitable for pooling and generally care about the memory management. In this case all he has to do is to derive the effect class from \emph{Memory::ClassAllocation} with the correct template parameters. The class controls the way instances of the deriving class are allocated and deallocated by overriding the \emph{new} and \emph{delete} operators. The usage of the class then does not change while the instance may be pooled.


\chapter{Platform setup}

To be able to build the engine for different platforms it was decided to concentrate all platform specific settings into one place. These include basic type definitions, macros, standard header file includes and containers. All of these can be found in the header files in the \verb/Setup/ directory under the source tree.

\section{Specific header files}
The main header file included in most compilation units is \verb/Settings.h/. It contains basic settings for the platform (macros controlling the behavior of libraries for example), but more importantly it aggregates other setup headers together.

In \verb/Platform.h/ you can find macros defining the currently used platform. These macros are then used in other parts of the project to branch the code for specific platforms in compile time. In \verb/BasicTypes.h/ there are definitions of simple types used in the whole project (integer, float, etc.). In \verb/Containers.h/ there are definitions of the STL-like containers. And \verb/ComplexTypes.h/ contains definitions of other complex STL-like data structures.

\verb/Memory_pre.h/ and \verb/Memory_post.h/ define the memory allocation method used by the project and includes their implementation from the memory subsystem.


\chapter{Utilities and reflection}

During the development of a game usually several helper classes and methods are needed such as those for math or containers. This kind of stuff does not fit anywhere because it is too general. Placing it in a specific subsystem would make it unusable anywhere else so they were aggregated in this namespace.

\section{Helper classes and methods}
There are several categories of utilities: containers (i.e. tree), math functions (i.e. hash) and design patterns (i.e. singleton). Here is the list of them with a brief description:

\begin{itemize}
  \item Array -- a templated representation of an array with the information about its size
  \item Callback -- a generic callback solution that uniformly wraps pointers to functions and/or methods
  \item DataContainer -- a class storing a pointer to a data buffer and its size
  \item FilesystemUtils -- utility functions for working with files and directories
  \item GlobalProperties -- globally accessible variables identified by string identifiers
  \item Hash -- custom hash and reverse hash functions
  \item MathUtils -- helper math functions
  \item ResourcePointers -- a file that gathers smart pointers of all resources together so that it can be included with no overhead
  \item Singleton -- a singleton pattern implementation
  \item SmartAssert -- a smart assert macro implementation
  \item StateMachine -- an implementation of a basic finite state machine
  \item StringConverter -- a set of functions for converting different values to and from a string
  \item StringKey -- a class that serves as a key into maps and other structures where strings are used to index data, but a high speed is necessary
  \item Timer -- a support for time measurement
  \item Tree -- an STL-like container class for n-ary trees
  \item XMLConverter -- a set of functions for reading/writing different values from/to XML
\end{itemize}

\section{RTTI}
\label{sec:utils-rtti}
RTTI is a shortage for \emph{Run-Time Type Information}. It is a mechanism which allows an instance of a class to know what its class is, the name of the class and other attributes. The instance is also able to create new instances of the same class, cloning itself.

RTTI is implemented using C++ templates. For using it a new class must derive from the \emph{Reflection::RTTIGlue} class which takes two template arguments. The first one is the new class and the second one is its predecessor in the RTTI hierarchy. If there is no parent then the new class should inherit from the \emph{Reflection::RTTIBaseClass} class. The mechanism will automatically call the static \emph{RegisterReflection} method of the new class during the startup if defined. In this method new properties and functions can be registered for the reflection (see section \ref{sec:utils-properties}) or a component dependency can be added by the \emph{AddComponentDependency} method.

\section{Properties}
\label{sec:utils-properties}
Properties are special RTTI attributes of classes which allow accessing data of their instances using string names. This greatly helps encapsulating classes and provides a uniform data access interface.

To make use of properties the class must already using RTTI. A getter and setter method for each of data provided as properties must be defined. Then the static \emph{RegisterReflection} function must be defined and inside its body the \emph{RegisterProperty} method must be called for each property providing pointers to the data getter and setter. To access the data of an instance the \verb/GetRTTI()->GetProperty()/ order on the instance is used. It returns the \emph{Reflection::PropertyHolder} class on which it is possible to call the template \emph{GetValue} or \emph{SetValue} methods.

It is also possible to set a custom function as a special property. The function must take the \emph{PropertyFunctionParameters} class as a single parameter and return \verb/void/. It must be registered by using the \emph{RegisterFunction} method. The function can be then used in a similar way as the common properties, but the \emph{CallFunction} method is used instead of the \emph{SetValue} one.

Each object instantiated from a class using RTTI can register its own properties which are related to an object instead of a class. They are called dynamic properties and they can be registered by the \emph{RegisterDynamicProperty} template method and unregistered by the \emph{UnregisterDynamicProperty} method whenever during an object life cycle. The class can react on a (un)registration of a property by overriding the \emph{DynamicPropertyChanged} method. Dynamic properties are accessible in the same way as regular ones. If a dynamic property has a same name as some regular one, the dynamic one is returned.


\section{Glossary}
This is a glossary of the most used terms in the previous sections:

\begin{description}
  \item[RTTI] -- a system for getting type information on run-time
  \item[Property] -- a class attribute accessible by its name that must be registered to the RTTI system
  \item[Dynamic property] -- data of any defined type associated to an object with RTTI that can be added and removed any time
\end{description}



%% A small distance to the other stuff in the table of contents (toc)
\addtocontents{toc}{\protect\vspace*{\baselineskip}}

%% The Bibliography 
\begin{thebibliography}{9}
\addcontentsline{toc}{chapter}{Bibliography} %'Bibliography' into toc
\bibitem {angelscript}AngelScript -- http://www.angelcode.com/angelscript
\bibitem {boost}Boost -- http://www.boost.org
\bibitem {box2d}Box2D -- http://www.box2d.org
\bibitem {cegui}CEGUI -- http://www.cegui.org.uk
\bibitem {dbglib}DbgLib -- http://dbg.sourceforge.net
\bibitem {expat}Expat -- http://expat.sourceforge.net
\bibitem {ois}OIS -- http://sourceforge.net/projects/wgois
\bibitem {opengl}OpenGL -- http://www.opengl.org
\bibitem {rthprofiler}Real-Time Hierarchical Profiling -- Greg Hjelstrom, Byon Garrabrant: Game Programming Gems 3, Charles River Media, 2002, ISBN: 1584502339
\bibitem {rudeconfig}RudeConfig -- http://rudeserver.com/config
\bibitem {sdl}SDL -- http://www.libsdl.org
\bibitem {soil}SOIL -- http://www.lonesock.net/soil.html
\bibitem {unittest}UnitTest++ -- http://unittest-cpp.sourceforge.net
\bibitem {gpg5}Kim Pallister: Game Programming Gems 5, Charles River Media, 2005, ISBN: 1584503521
\bibitem {tree}Kasper Peeters, http://www.aei.mpg.de/~peekas/tree
\bibitem {allocator}http://www.sjbrown.co.uk/2004/05/01/pooled-allocators-for-the-stl
\bibitem {glew}http://glew.sourceforge.net
\bibitem {objloader}http://www.dhpoware.com
\bibitem {pluscallback}http://codeplea.com/pluscallback
\bibitem {obj}Wavefront OBJ file structure -- http://en.wikipedia.org/wiki/Obj
\bibitem {cegui-doc}CEGUI documentation -- http://cegui.org.uk/api\_reference/index.html
\bibitem {angelscript-doc}AngelScript documentation -- file /AngelScript/index.html
\bibitem {ISO-639-1}ISO 639-1 -- http://en.wikipedia.org/wiki/List\_of\_ISO\_639-1\_codes
\bibitem {ISO-3166-1}ISO 3166-1 alpha-2 -- http://en.wikipedia.org/wiki/ISO\_3166-1\_alpha-2
\end{thebibliography}

%% The List of Figures
\clearpage
\listoffigures
\addcontentsline{toc}{chapter}{List of Figures}

%% The List of Tables
\clearpage
\listoftables
\addcontentsline{toc}{chapter}{List of Tables}

\end{document}