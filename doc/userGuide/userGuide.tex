\documentclass[a4paper,12pt]{article}
%\documentclass[a4paper,10pt]{scrartcl}

\usepackage[utf8x]{inputenc}

\title{Ocerus: User Guide}
\author{Michal Cevora, Lukas Hermann,Ondrej Mocny, Tomas Svoboda}
\date{}

\pdfinfo{%
  /Title    (Ocerus: User Guide)
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\usepackage{hyperref}
\usepackage{listings}
%\usepackage{lua}


\begin{document}
\maketitle

\tableofcontents

\section{Introduction}

Welcome to the Ocerus User guide, a document that shows basic usage of the Ocerus Engine from the game designer perspective. With Ocerus you are able to create modern 2D games in an easy and straightforward manner. Ocerus can also handle 3D objects, so you can easily place your 3D models onto the 2D game plane.

%TODO: Dopsat uvod, jeste alespon odstavec o tom jak je Ocerus cool.

The purpose of this document is to show you the basics of using Ocerus and by a simple project demonstration it should help you get set up and creating wonderful games in no time. 

Throughout the user guide, the basic game editing techniques will be presented on a sample pinball game, that will be created from scratch. This guide concentrates only on real basics, so the game will be rather simple, but complex enough to demonstrate all necessary use cases.

\section{Installation}
The Ocerus project is currently hosted at SourceForge and its homepage is \url{http://ocerus.sourceforge.net}. On that page, you can find the brief description of the project, location of project resources, such as source code repository and installation packages. To download the latest installation package, navigate your browser to the \href{http://sourceforge.net/projects/ocerus/files/}{Ocerus download page}. Just download the installation package from there and launch it. Installation process is rather straightforward, so a few next button clicks will do the job. We are ready for our first launch.

\section{First steps}
To start Ocerus, click the Ocerus icon on your desktop or in the start menu. In a few moments, the main Ocerus window appears (see FIGURE). In the top edge of the window there is main menu. You can use this menu to carry out various actions in the editor. The rest of the window is empty, because there is nothing that could be edited at the moment. Let's start with creating a new project.

\section{Creating the project}
By selecting the \textbf{File $\to$ Create Project} command from the main menu, open the \textbf{Create Project} dialog. Type in the name of the project and browse the location where your project will reside. Note that a new subdirectory in the chosen location will be created and it will be named the same as the project. That is why you should avoid using any nonstandard characters in the project name. Name the project \texttt{Pinball} and use any location you like. When the \textbf{OK} button is clicked, the new project is created.

A project in Ocerus represents a single game, so for every single game that you design, you need to create another project. Behind the scene, projects are ordinary directories on your file system with resource files representing your game content, such as images, models, scripts, etc. Structure of the project directory is on your own consideration, but it's recommended to stick with the default structure that is created for new projects.

The Ocerus window is still almost empty. Let's create a \textbf{scene}.

\section{Creating scenes}
Select the \textbf{Scene $\to$ New Scene} command from the main menu. In the \textbf{New Scene} dialog select the scenes sub-directory and type \texttt{scene1.xml} as the scene filename (see FIGURE). When you are ready, click the \textbf{OK} button and the new scene will be created and automatically opened.

After a scene is opened, viewports and views are displayed (see FIGURE). Viewports are framed areas that provide a view to the current scene. There are two viewports in Ocerus editor. The \textbf{Game Viewport} (the upper on) shows the scene in the same way as it is rendered in the resulting game, whereas the \textbf{Editor Viewport} (the lower one) shows the scene with editing tools visible. Viewports are surrounded with views that provide information related to current scene or current entity. There are five views: \textbf{Entity}, \textbf{Hierarchy}, \textbf{Layers}, \textbf{Prototypes} and \textbf{Resources}. All these views will be discussed later, now we move on creating an entity.

\section{Creating an entity}
To create an entity, select the \textbf{Scene $\to$ New Entity} command from the main menu and type the entity name. In our sample project there will be a ball that will bounce over the area, so we name the entity \texttt{Ball}. Click the \textbf{OK} button and the new entity appears in the \textbf{Hierarchy} view. Select the entity by clicking it in the view.

As soon as an entity is selected, the \textbf{Entity} view shows related information about it (see FIGURE). First group window in the view shows basic properties of the entity, such as its ID and its name. Some of these properties can be modified by clicking the property value and editing it. Note that if the property value is grayed, then it cannot be edited directly, or it cannot be edited at all.

Entities in Ocerus are composed of components that determine their behavior and functionality and these components can have another properties. All components and their properties are shown just under the \textbf{General info} group window in the \textbf{Entity} view and the properties can be edited the same way as the ID and name property above. (see FIGURE)

Almost any entity that you will create is composed at least of the \textbf{Transform} component. Roughly speaking, entities with this component are such entities that are placed to a specific position in our virtual 2D world. They can move around, change its size and rotate. These transformations are represented by the \textbf{position}, \textbf{scale} and \textbf{angle} properties. These properties are also reflected in the \textbf{Editor Viewport}. Although our ball does not have a graphics yet, it is represented in the viewport as a red square. You can try to modify the \textbf{position} property and see the red square move to another spot. However, if you change the \textbf{scale} property, you won't see any difference at all. We need to give our entity a visual form. This can be achieved with the \textbf{Sprite} component.

\section{Creating a component}
Make sure that the \texttt{Ball} entity is selected, then click the \textbf{Edit $\to$ New Component $\to$ Sprite} action from the main menu. Our entity is now represented by a red filled square with the \textbf{NULL TEXTURE} text and a new group window is appended to the \textbf{Entity} view (see FIGURE). Notice that the red filled square is also visible in the \textbf{Game viewport}. This is because our entity has a visual form now. The default null texture is used, however. To give our ball a more appealing appearance, we have to change the \textbf{texture} property in its \textbf{Sprite} component. But how to get our fancy ball texture into Ocerus?

\section{Adding graphics content}
Every file and directory that is placed into the project directory hierarchy is visible in the \textbf{Resources} view (see FIGURE). To put files with your textures into the project, simply copy them somewhere into the project directory. When you add a file into the project directory, Ocerus automatically detects the type of the file and creates the suitable type of resource. The type of the resource is represented by an icon next to the resource name in the \textbf{Resource} window.

You can either use the \texttt{ball.png} texture from the archive provided with this document, or you can create or get any texture you like. Either way, copy it to textures subdirectory of your project directory. Switch back to Ocerus and see that \texttt{ball.png} has appeared in the \textbf{Resources} view.

Now Ocerus is aware of our texture. Let's use it as a \textbf{texture} property of our entity.

\section{Linking resources to properties}
Properties that contain a resource (resource properties) cannot be edited with a simple text editor and therefore they are grayed. To link a resource to such property, you have to drag the resource and drop it to the grayed area of the property. Click the \texttt{ball.png} resource in the \textbf{Resource} view and drag it to \textbf{texture} property in the \textbf{Entity} view (see FIGURE). If you were successful, you should end up with a ball image displayed in both viewports.

Now that we have an entity with a transform and sprite component, we can take a look at using editing tools.

\section{Moving, rotating and scaling entities}
We have already discussed the way to move, rotate and scale an entity by editing its transform properties. This is, however, very uncomfortable. Ocerus provides editing tools to facilitate these operations. There are four editing tools in Ocerus: \textbf{move} tool, \textbf{rotate} tool, \textbf{rotate-y} tool and \textbf{scale} tool and they are accessible from the toolbar right from the main menu (see FIGURE). You can switch among these editing tools by clicking the corresponding icon, which becomes pressed.

When the \textbf{move} tool is active, you can move the selected entity by dragging it in the editor viewport. By selecting the \textbf{rotate} tool and dragging the entity back and forth, you can rotate the entity and lastly the scale tool allows you to change the size of the entity, again, by dragging the entity in the editor viewport. Take some time to familiarize with these tools as they are vital for rapid development in Ocerus. Consider using keyboard shortcuts to become even faster (click the \textbf{Help $\to$ Shortcuts} action in the main menu to display the list of keyboard shortcuts).

\section{Defining a collision polygon}
Although our ball has a texture already, Ocerus has no clue what its shape is. As soon as we introduce physics into our game, it is necessary that every entity that is influenced by physic has a collision polygon defined. Ocerus needs to know these polygons in order to properly determine whether two entities collide with each other or not. To define a collision polygon, add the \textbf{PolygonCollider} component to our \texttt{Ball} entity (select \textbf{Edit $\to$ New Component $\to$ PolygonCollider}). The polygon is then defined as a list of points in the \textbf{polygon} property of the component. For our ball we will create an octagon with the following points:

[0, -0,5], [0.35, -0.35], [0.5, 0], [0.35, 0.35], [0, 0.5], [-0,35, 0.35], [-0.5, 0], [-0.35, -0.35]

%TODO: az budou nove ikonky v array editoru, dopise se tady jakym zpusobem se pracuje s array editorem a jak to tam ma teda vlozit]

Enter the points according to FIGURE and save. After the new collision polygon is saved to our entity, it is displayed as a blue outline in the editor viewport. If you used your own texture, you may need to modify these points to make the polygon aligned with the texture.

Our ball entity has a collision polygon now, which means that if physics is applied to that entity, it will collide with another entities according to their collision polygons. So to really see the \textbf{PolygonCollider} in action, we have to add physics.

\section{Adding physics}
If you want an entity to be affected by the Ocerus physical engine, you need to add either of the following components to the entity. These components are \textbf{StaticBody} and \textbf{DynamicBody}.

Entities with the \textbf{StaticBody} component are stationary building blocks in your world. They are never moved by the physical engine and their primary function is to build borders and walls. On the other hand, entities with the \textbf{DynamicBody} component are used for objects that are affected by gravitation force and other forces. Our ball entity is an example of entity with the \textbf{DynamicBody} component.

By selecting the \textbf{Edit $\to$ New Component $\to$ DynamicBody} action, add the \textbf{DynamicBody} component to the \texttt{Ball} entity. Now the ball is affected by the gravitation force.

Ocerus does not implement the real gravitation force in the sense that all objects attract themselves. Instead, all objects are attracted straight down. It means that as soon as we start our so far created game, our ball would infinitely fall down. Let's create some barriers in our world.

\textbf{Task 1.} Create a new entity called \texttt{Platform}, add \textbf{Sprite} component and use the \texttt{steel.jpg} file as the texture. Add the \textbf{PolygonCollider} component and set polygon points to [5.12, -5.12], [5.12, 5.12], [5.12, -5.12], [-5.12, -5.12]. Add the \textbf{StaticBody} component and finally use edit tools to shape the square into a slightly sloped platform and place it under the ball (see FIGURE). If you have any problems with this task, please read the corresponding sections above.

If you are done, let's see what happens if we start the simulation.

\section{Starting the action}
While we were building our scene so far, everything was static even though we added physics to our entities. This is because the action is stopped. During the editing you can arrange the initial state of your scene and when you feel like testing everything, you can animate the scene by starting the action. Action is controlled by the action toolbar (see FIGURE) that is composed of three buttons. Clicking the \textbf{Play} button will start the action from the current state, clicking the \textbf{Pause} button will pause action in the current state and clicking the \textbf{Stop} button will stop the action and resets the scene to the initial state. After the action is started, you can still use edit tools and edit entity properties. Changes that you make will be discarded as soon as you stop the action however.

Click the \textbf{Play} button and see the ball fall down on the platform. If your platform is sloped enough, you will see the ball roll down on the platform. You will probably see that the movement is not really smooth. This is because we used a collision polygon with only eight vertices for our ball. Try to double or even triple the number of the vertices and the movement will be more smooth.
 
Now it's time to design our pinball machine. The pinball machine will be composed of many platforms, so we need to create a lot of new entities. As you could see when you created the first platform entity, the process is not quite short and you probably don't want to imagine how long it would take to create all those new entities the same way. For purposes of reusing existing entities there are a few tricks in Ocerus. The first one is to use the \textbf{Edit $\to$ Duplicate Entity} action in the main menu. This action will duplicate the selected entity. You can duplicate the first platform entity a couple of times to have enough entities to design the pinball machine. Nevertheless, duplicating entities is not recommended in this case. 

Imagine that you decide to change the texture property of all your platform entities one day. If you used the duplicate entity method, you need to modify the texture property of every platform entity in each scene in your project. This issue is addressed by using prototypes, that allow some properties to be shared among multiple entities.

\section{Using prototypes}
Prototypes are special entity templates. They are not related to a concrete scene, rather they are saved in \texttt{Prototypes.xml} file and can be accessed from any scene in the project. When you need to create a specific entity many times, you can create it once and then create a prototype from it. Then you can use this prototype as many times as you like.

To create a prototype from the \texttt{Platform} entity, make sure it is selected and then select the \textbf{Edit $\to$ Create Prototype} action from the main menu. A new item appears in the \textbf{Prototypes} view. All prototypes in your project are displayed there and instantiation of prototypes is as easy as dragging the prototype from the view to the \textbf{Editor viewport}. Drag your new prototype to the viewport a couple of times to have enough entities to build the pinball machine.

When an entity is created from a prototype, this entity is linked to that prototype. This means that changes made to the prototype are propagated to all entities linked to it. However, this behavior is limited to only shared properties.

\section{Shared properties}
Click the \texttt{Platform} prototype in the \textbf{Prototypes} view and look at the \textbf{Entity} view (see FIGURE). On the left of every property there is a check box that controls, whether the property is shared. If you change a property that has this check box checked, the change will be propagated to its linked entities. This concept is very handy if you need to globally change some properties across several scenes in your project. You only have to change the prototype and Ocerus will do the rest.

Select a \texttt{Platform} entity from the \textbf{Hierarchy} view and again look at the \textbf{Entity} view (see FIGURE). All properties that are shared have a lock icon on the right and cannot be edited.

\textbf{Task 2.} Now with the knowledge of prototypes and shared properties you should be able to design your pinball machine, so it would look similar to figure FIGURE. Use the \texttt{Platform} prototype to build all barriers. Also create the \texttt{Flipper} prototype that would be similar to \texttt{Platform} prototype, except that it will have \textbf{DynamicBody} component instead of \textbf{StaticBody} component. Create two instances of this prototype: \texttt{LeftFlipper} and \texttt{RightFlipper}. \textit{Hint: To create the \texttt{Flipper} prototype you can instantiate the \texttt{Platform} prototype and unlink it from the prototype by clicking the cross button on the right of the \textbf{Prototype} property in the \textbf{Entity} view. Then modify the entity and create a prototype from it.}
%TODO: tady se predpoklada, ze prototyp se unlinkuje kliknutim na krizek u prototypu, coz neni soucasny stav - momentalne je tam tlacitko RM. Az to bude hotove, muzete tuto poznamku smazat.


\section{Entity Hierarchy}
As the number of entities in your scene grows, it becomes harder not to get lost. Fortunately, Ocerus provides means for hierarchical organization through the \textbf{Hierarchy} view. Unlike file system organization, each and every entity can become a parent of another entities, so there are no folders in this concept. In fact, it's not an issue at all. Not only that you can use dummy entities (entities with no components) as folders, you are even encouraged to do so.

Entities can be organized into hierarchy by dragging them to their parents. This way you can move any entity to become a child of another entity. To move the entity to the top of the hierarchy (next to another top level elements), you need to use the \textbf{reparent up} action a couple of times. Just right click on the entity and select the \textbf{reparent up} action and the entity will move one level upwards in the hierarchy.

Entities can be also ordered among theirs siblings. Use the \textbf{move up} and \textbf{move down} commands to move an entity before its preceding sibling or after its succeeding sibling.

Now try to organize entities in your pinball scene. Create a dummy entity called \texttt{Platforms}, remove the \textbf{Transform} component by clicking the red cross on the right of the component title in the \textbf{Entity} view and move all platform entities under the Platforms entity (see FIGURE).

To further improve the graphics appearance of our scene, we will add a background picture behind our pinball machine. Create an entity called \texttt{Background} and add the \textbf{Sprite} component to it. Use the \texttt{background.jpg} image as its texture. Notice that the \texttt{Background} entity is displayed above your pinball machine. So far we didn't have to take the entities' sprite order into account, but now we need to make sure that background stays behind the pinball machine. This can be achieved by using layers.  

\section{Using layers}

If you look at the \textbf{Layers} view, you can see the \texttt{Initial Layer} there. Every scene has to have at least one layer and this one is automatically created. You can click on the plus sign on the left of the layer name to expand it. Every entity that you created so far is located in this layer. To make sure that our \texttt{Background} entity will stay behind all other entities, you have to create a new layer.

To create a layer, right click on an existing layer in the layer view and select the \textbf{new layer} command. A prompt asking for the layer name will pop up. Type \texttt{Background} and click the \textbf{OK} button. In case the \texttt{Background} layer is not under the \texttt{Initial Layer}, use the \textbf{move down} command in the layer's context menu. Finally expand both layers and drag the \texttt{Background} entity to the background layer (or use the \textbf{move down} command in the entity's context menu).

Notice that the initial layer is printed in boldface. This means that the initial layer the active one. If you are selecting an entity in the editor viewport, only entities in the active layer are selectable. To switch the active layer, double click on the another layer and it becomes active. You can also toggle the layer visibility by clicking the eye icon on the right of the layer.

The graphical appearance of our scene is done, as well as the physics in our scene. Now it's time to write the underlying scripts to implement the game logic.

\section{Scripting}
Ocerus engine allows to implement the game behavior using the scripting engine. Although writing scripts is indeed programming, it differs from core Ocerus programming in many ways. First, Ocerus scripting environment was designed for game designers, rather than senior C++ programmers. It does not overwhelm you with unnecessary complexity of the "guts" of the engine, but it rather provides only the relevant means that are used in most cases. Also the scripting language is simpler than C++.

We are going to implement the main control of our game - the flippers. Make sure that you have already created the \texttt{Flipper} prototype, as well as both \texttt{Flipper} entities. Now select the \texttt{Flipper} prototype and add the \textbf{Script} component to it.

The \textbf{Script} component allows to implement a custom behavior using the scripting language. As soon as you add the component, you can see the \textbf{ScriptModules} property in the \textbf{Entity} view. This property contains a list of script files that are associated with this entity. Now it's time to create our little script. Open your favorite text editor and copy the following code (or use the \texttt{flipper.as} file from the archive).

\lstinputlisting[language=c,
	basicstyle=\small,
	stringstyle=\ttfamily,
	showstringspaces=false,
	breaklines=true,
	caption=flipper.as,
	label={flipper.as}]{flipper.as}


Now save the file as \texttt{flipper.as} and copy it into the \texttt{scripts} subdirectory in your project. Back in Ocerus, select the \texttt{Flipper} prototype and click the \textbf{Add} button next to the \textbf{ScriptModules} property. Drag the \texttt{flipper.as} resource from the \textbf{Resources} view to the \textbf{NULL} field in the modules list and click the \textbf{Save} button.
%TODO revidovat jakmile se opravi manipulace s poli (ikonky misto Add, Rvrt, Save).
If everything went well, your script gets loaded and a couple of new properties appear in the \textbf{Script} component part of the \textbf{Entity} view. These properties are defined in the script and they allow to parametrize the scripted behavior. In our script, there are two properties: \textbf{LeftSided} and \textbf{Pivot}. The \textbf{LeftSided} property determines which flipper is the left one and which is the another one and the \textbf{Pivot} property defines the location of the pivot point.

Select the \texttt{LeftFlipper} entity and check its \textbf{LeftSided} property checkbox. 
%TODO jak nastavit spravne Pivot?? metodou pokus omyl?

When you are ready, you can see your flippers in action. Start the action by pressing the \textbf{Play} button on the toolbar and try to control your flippers with the \textbf{Left} and the \textbf{Right} key.


\section{GUI}
In the last 



\end{document}
