\newcommand{\TitleText}{Ocerus User Guide}
\documentclass[a4paper,12pt,titlepage]{article}
\input{../CommonHeader.tex}
\graphicspath{{./screenshots/}}


\section{Introduction}

Welcome to the Ocerus User guide. With the Ocerus you can create modern 2D games in an easy and
straightforward manner. Ocerus can also handle 3D objects, so you can easily place your 3D models onto the 2D
game plane.

The aim of this guide is to teach you the basics of the Ocerus usage, and by a simple project demonstration,
it should help you get set up and begin creating wonderful games in no time. 

Throughout the user guide, we are going to show you basic game editing techniques on a sample pinball
game, that you create from scratch. This guide concentrates only on real basics, so the game is rather
simple but complex enough to demonstrate all necessary use cases.

\section{Getting Ocerus}
The Ocerus project is currently hosted at SourceForge and its homepage is \url{http://ocerus.sourceforge.net}.
On that page, you can find project resources, such as source code repository and installation packages. To
download the latest installation package, navigate your browser to
the \href{http://sourceforge.net/projects/ocerus/files/}{Ocerus download page} and download the latest
version.

\section{Installation}
To install Ocerus, launch the installation file. Installation process is rather straightforward, so a few next
button clicks will do the job. We are ready for our first launch.

\section{First steps}
To start Ocerus, click the Ocerus icon on your desktop or in the start menu. In a few moments, the main Ocerus
window appears (see figure~\ref{fig:ocerus_initial}). In the top edge of the window is a main menu. You can
use this menu to carry out various actions in the editor. The rest of the window contains views that will be
discussed later. If something is unclear you can see the description of all editor controls in the appendix \ref{sec:editor_controls}. For now let's start with creating a new project.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=\textwidth]{Initial}
 \end{center}
 \caption{Ocerus window}
 \label{fig:ocerus_initial}
\end{figure}

\section{Creating the project}
By selecting the \textbf{File $\to$ Create Project} command from the main menu, open the \textbf{Create
Project} dialog. Type \texttt{Pinball} into the name field and browse the location where your project will
reside. Note that a new subdirectory in the chosen location will be created and it will be named the same as
the project. That is why you should avoid using any nonstandard characters in the project name. When the
\textbf{OK} button is clicked, the new project is created.

{\itshape
A project in Ocerus represents a single game, so for every single game that you design, you need to create
another project. Behind the scene, projects are ordinary directories on your file system with resource files
representing your game content, such as images, models, scripts, etc. Structure of the project directory is on
your own consideration, but we recommend to stick with the default structure that is created for new
projects.
}

Although a default scene was automatically created together with the project, we are going to create another
one. So let's create a \textbf{scene}.

\section{Creating scenes}
Select the \textbf{Scene $\to$ New Scene} command from the main menu. Ocerus can ask you whether you want to
save the current scene (this is the default scene that was automatically created). In that case, click
\textbf{No} and the \textbf{New Scene} dialog should appear.

In the \textbf{New Scene} dialog click on the folder icon to create a subfolder. Name it \texttt{scenes} and enter the subfolder. Then type in \texttt{gameplay} as the scene
filename (see figure~\ref{fig:new_scene}). When you are ready, click the \textbf{OK} button and the new scene
will be created and automatically opened.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[scale=0.65]{NewScene}
 \end{center}
 \caption{Creating a scene}
 \label{fig:new_scene}
\end{figure}

{\itshape
Scenes are your virtual playgrounds where your game takes place. Generally speaking they consist of an
indefinite plane with your game elements, such as player's avatar or enemies, on it. You can think of a scene
as a game level. 
}

After a scene is opened, viewports and views are displayed (see figure~\ref{fig:new_scene_created}). Viewports
are framed areas that provide a view to the current scene. There are two viewports in the Ocerus editor. The
\textbf{Game Viewport} (the upper one) shows the scene in the same way as it is rendered in the resulting
game, whereas the \textbf{Editor Viewport} (the lower one) shows the scene with editing tools visible.
Viewports are surrounded with views that provide information related to the current scene or current entity.
There are five views: \textbf{Entity}, \textbf{Hierarchy}, \textbf{Layers}, \textbf{Prototypes} and
\textbf{Resources}. All these views will be discussed later, now we move on creating the protagonist of our
game. You are right, we are talking about the ball.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=\textwidth]{NewSceneCreated}
 \end{center}
 \caption{Ocerus with opened scene}
 \label{fig:new_scene_created}
\end{figure}


\section{Creating entities}
To create an entity, select the \textbf{Edit $\to$ New Entity} command from the main menu and type the entity
name. In our sample project there will be a ball that will bounce over the area, so we name the entity
\texttt{Ball}. Click the \textbf{OK} button and the new entity appears in the \textbf{Hierarchy} view. Select
the entity by clicking it in the view.

As soon as an entity is selected, the \textbf{Entity} view shows related information about it (see
figure~\ref{fig:new_entity_created}). First section in the view shows basic properties of the entity, such as
its ID and its name. Some of these properties can be modified by clicking the property value and editing it.
Note that if the property value is grayed, then it cannot be edited directly, or it cannot be edited at all.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=\textwidth]{NewEntityCreated}
 \end{center}
 \caption{Newly created entity}
 \label{fig:new_entity_created}
\end{figure}

Entities in Ocerus are composed of components that determine their behavior and functionality and these
components can have other properties. All components and their properties are shown just under the
\textbf{General} section in the \textbf{Entity} view and these properties can be edited the same way as the ID
and name property above.

Almost any entity that you will create is composed at least of the \textbf{Transform} component. Roughly
speaking, entities with this component are such entities that are placed to a specific position in our virtual
2D world. They can move around, change its size and rotate. These transformations are represented by the
\textbf{position}, \textbf{scale} and \textbf{angle} properties. These properties are also reflected in the
\textbf{Editor Viewport}. Although our ball does not have a graphics yet, it is represented in the viewport as
a red square. You can try to modify the \textbf{position} property and see the red square move to another
spot. However, if you change the \textbf{scale} property, you won't see any difference at all. We need to give
our entity a visual form. This can be achieved with the \textbf{Sprite} component.

\section{Creating components}
Make sure that the \texttt{Ball} entity is selected, then click the \textbf{Edit $\to$ New Component $\to$
Sprite} action from the main menu. Our entity is now represented by a red filled square with the \texttt{NULL
TEXTURE} text and a new section is appended to the \textbf{Entity} view (see
figure~\ref{fig:entity_with_sprite}). Notice that the red filled square is also visible in the \textbf{Game
viewport}. This is because our entity has a visual form now. The default null texture is used, however. To
give our ball a more appealing appearance, we have to change the \textbf{texture} property in its
\textbf{Sprite} component. But how to get our fancy ball texture into Ocerus?

\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=\textwidth]{EntityWithSprite}
 \end{center}
 \caption{Entity with the Sprite component}
 \label{fig:entity_with_sprite}
\end{figure}

\section{Adding graphics content}
Every file and directory that is placed into the project directory hierarchy is visible in the
\textbf{Resources} view. To put files with your textures into the project, simply copy them somewhere into the
project directory. When you add a file into the project directory, Ocerus automatically detects the type of
the file and creates the suitable type of resource. The type of the resource is represented by an icon next to
the resource name in the \textbf{Resource} view.

You can either use the \texttt{ball.png} texture from the \texttt{textures} directory in the
\hyperref[sec:archive]{archive} provided with this document, or you can create or get any texture you like
(see supported formats on page \pageref{sec:supported_formats}). Either way, copy it to the textures
subdirectory of your project directory. Switch back to Ocerus and see that \texttt{ball.png} has appeared in
the \textbf{Resources} view (see figure~\ref{fig:link_texture}).

Now Ocerus is aware of our texture. Let's use it as a \textbf{texture} property of our entity.

\section{Linking resources to properties}
Properties that contain a resource (resource properties) cannot be edited with a simple text editor and
therefore they are grayed. To link a resource to such property, you have to drag the resource and drop it to
the grayed area of the property. Click the \texttt{ball.png} resource in the \textbf{Resource} view and drag
it to \textbf{texture} property in the \textbf{Entity} view (see figure~\ref{fig:link_texture}). If you were
successful, you should end up with a ball image displayed in both viewports.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=\textwidth]{LinkTexture}
 \end{center}
 \caption{Linking texture to an entity}
 \label{fig:link_texture}
\end{figure}

Now that we have an entity with a transform and sprite component, we can take a look at using editing tools.

\section{Controlling editor camera}
To look around in your scene, you need to control the camera of the \textbf{Editor viewport}. Use the
\textbf{arrow keys} on your keyboard to \textbf{move} the camera in the viewport. You can also move the camera
with the \textbf{middle mouse button}. Simply click somewhere in the viewport with the middle mouse button and
drag to move the camera. Finally you can \textbf{zoom} the viewport using the \textbf{scroll wheel} on your
mouse.

\section{Moving, rotating and scaling entities}
We have already discussed the way to move, rotate and scale an entity by editing its transform properties.
This is, however, very uncomfortable. Ocerus provides editing tools to facilitate these operations. There are
four editing tools in Ocerus: \textbf{move} tool, \textbf{rotate} tool, \textbf{rotate-y} tool and
\textbf{scale} tool and they are accessible from the toolbar right from the main menu (see
figure~\ref{fig:editing_tools}). You can switch among these editing tools by clicking the corresponding icon,
which becomes pressed.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[scale=0.65]{EditingTools}
 \end{center}
 \caption{Editing Tools}
 \label{fig:editing_tools}
\end{figure}

When the \textbf{move} tool is active, you can move the selected entity by dragging it in the editor viewport.
By selecting the \textbf{rotate} tool and dragging the entity back and forth, you can rotate the entity and
lastly the scale tool allows you to change the size of the entity, again, by dragging the entity in the editor
viewport. Take some time to familiarize with these tools as they are vital for rapid development in the
Ocerus. Consider using keyboard shortcuts to become even faster (click the \textbf{Help $\to$ Shortcuts}
action in the main menu to display the list of keyboard shortcuts).

\begin{wrapfigure}{r}{0.35\textwidth}
\capstart
\begin{center}
  \includegraphics[scale=0.65]{PolygonCollider}
 \end{center}
 \caption{Defining octagon collision polygon}
 \label{fig:polygon_collider}
\end{wrapfigure}

\section{Defining a collision polygon}
Although our ball has a texture already, Ocerus has no clue what its shape is. As soon as we introduce physics
into our game, it is necessary that every entity that is influenced by physics has a collision polygon
defined. Ocerus needs to know these polygons in order to properly determine whether two entities collide with
each other or not. To define a collision polygon, add the \textbf{PolygonCollider} component to our
\texttt{Ball} entity (select \textbf{Edit $\to$ New Component $\to$ PolygonCollider}). New component now
appears under the \textbf{Sprite} component in the \textbf{Entity} view. The polygon is then defined as a list
of points in the \textbf{polygon} property of the component. For our ball we will create an octagon with the
following points: [0, -0,5], [0.35, -0.35], [0.5, 0], [0.35, 0.35], [0, 0.5], [-0,35, 0.35], [-0.5, 0] and
[-0.35, -0.35].

Use the green plus button to add eight vertices to the \textbf{Polygon} property and then enter the points
according to the figure~\ref{fig:polygon_collider}. When you are ready, click the blue diskette button to save
the list. After the new collision polygon is saved to our entity, it is displayed as a blue outline in the
editor viewport. If you used your own texture, you may need to modify these points to make the polygon aligned
with the texture.

Our ball entity has a collision polygon now, which means that if physics is applied to that entity, it will
collide with another entities according to their collision polygons. So to really see the
\textbf{PolygonCollider} in action, we have to add physics.

\section{Adding physics}
If you want an entity to be affected by the Ocerus physical engine, you need to add either of the following
components to the entity. These components are \textbf{StaticBody} and \textbf{DynamicBody}.

Entities with the \textbf{StaticBody} component are stationary building blocks in your world. They are never
moved by the physical engine and their primary function is to build borders and walls. On the other hand,
entities with the \textbf{DynamicBody} component are used for objects that are affected by gravitation force
and other forces. Our ball entity is an example of entity with the \textbf{DynamicBody} component.

By selecting the \textbf{Edit $\to$ New Component $\to$ DynamicBody} action, add the \textbf{DynamicBody}
component to the \texttt{Ball} entity. Now the ball is affected by the gravitation force.

Ocerus does not implement the real gravitation force in the sense that all objects attract themselves.
Instead, all objects are attracted straight down. It means that as soon as we start our so far created game,
our ball would infinitely fall down. Let's create some barriers in our world.

\textbf{Task 1.} Create a new entity called \texttt{Platform}, add \textbf{Sprite} component and use the
\texttt{textures\textbackslash steel.jpg} file from the \hyperref[sec:archive]{archive} as the texture. Add
the \textbf{PolygonCollider} component and set polygon points to [5.12, -5.12], [5.12, 5.12], [-5.12, 5.12],
[-5.12, -5.12]. Add the \textbf{StaticBody} component and finally use edit tools to shape the square into a
slightly sloped platform and place it under the ball (see figure~\ref{fig:task_1}). If you have any problems
with this task, please read the corresponding sections above.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[scale=0.65]{Task1}
 \end{center}
 \caption{Task 1}
 \label{fig:task_1}
\end{figure}

If you are done, let's see what happens if we start the simulation.

\section{Starting the action}
While we were building our scene so far, everything was static even though we added physics to our entities.
This is because the action is stopped. During the editing you can arrange the initial state of your scene and
when you feel like testing everything, you can animate the scene by starting the action. Action is controlled
by the action toolbar (see figure~\ref{fig:action_toolbar}), which is composed of three buttons. Clicking the
\textbf{Play} button will start the action from the current state, clicking the \textbf{Pause} button will
pause action in the current state and clicking the \textbf{Stop} button will stop the action and resets the
scene to the initial state. After the action is started, you can still use edit tools and edit entity
properties. Changes that you make will be discarded as soon as you stop the action however.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[scale=0.65]{ActionToolbar}
 \end{center}
 \caption{Action Toolbar}
 \label{fig:action_toolbar}
\end{figure}

Click the \textbf{Play} button and see the ball fall down on the platform. If your platform is sloped enough,
you will see the ball roll down on the platform. You will probably see that the movement is not really smooth.
This is because we used a collision polygon with only eight vertices for our ball. Try to double or even
triple the number of the vertices and the movement will be more smooth. Note that Ocerus does not provide
colliders with rounded shapes.
 
Now it's time to design our pinball machine. The pinball machine will be composed of many platforms, so we
need to create a lot of new entities. As you could see when you created the first platform entity, the process
is not quite short and you probably don't want to imagine how long it would take to create all those new
entities the same way. For purposes of reusing existing entities there are few tricks in the Ocerus. The first
one is to use the \textbf{Edit $\to$ Duplicate Entity} action in the main menu. This action will duplicate the
selected entity. You can duplicate the first platform entity a couple of times to have enough entities to
design the pinball machine. Nevertheless, duplicating entities is not really recommended in this case. 

Imagine that you decide to change the texture property of all your platform entities one day. If you used the
duplicate entity method, you need to modify the texture property of every platform entity in each scene in
your project. This issue is addressed by using prototypes, that allow some properties to be shared among
multiple entities.

\section{Using prototypes}
Prototypes are special entity templates. They are not related to a concrete scene, rather they are saved in
\texttt{Prototypes.xml} file and can be accessed from any scene in the project. When you need to create a
specific entity many times, you can create it once and then create a prototype from it. Then you can use this
prototype as many times as you like.

To create a prototype from the \texttt{Platform} entity, make sure it is selected and then select the
\textbf{Edit $\to$ Create Prototype} action from the main menu. A new item appears in the \textbf{Prototypes}
view. All prototypes in your project are displayed there and instantiation of prototypes is as easy as
dragging the prototype from the \textbf{Prototypes} view to the \textbf{Editor viewport}. Drag your new
prototype to the viewport a couple of times to have enough entities to build the pinball machine.

When an entity is created from a prototype, this entity is linked to that prototype. This means that changes
made to the prototype are propagated to all entities linked to it. However, this behavior is limited to only
shared properties.

\section{Shared properties}

\begin{wrapfigure}{r}{0.35\textwidth}
\vspace{-20pt}
\capstart
\begin{center}
  \includegraphics[scale=0.65]{SharedProperties}
 \end{center}
 \vspace{-20pt}
 \caption{Shared Properties}
 \label{fig:shared_properties}
 \vspace{-10pt}
\end{wrapfigure}

Click the \texttt{Platform} prototype in the \textbf{Prototypes} view and look at the \textbf{Entity} view
(see figure~\ref{fig:shared_properties}). On the left of every property there is a check box that controls,
whether the property is shared. If you change a property that has this check box checked, the change will be
propagated to its linked entities. This concept is very handy if you need to globally change some properties
across several scenes in your project. You only have to change the prototype and the Ocerus will do the rest.

\begin{wrapfigure}{r}{0.35\textwidth}
\vspace{-20pt}
\capstart
\begin{center}
  \includegraphics[scale=0.65]{LockedProperties}
 \end{center}
 \vspace{-20pt}
 \caption{Locked Properties}
 \label{fig:locked_properties}
 \vspace{-10pt}
\end{wrapfigure}

Select the \texttt{Platform} entity from the \textbf{Hierarchy} view and again look at the \textbf{Entity}
view (see figure~\ref{fig:locked_properties}). All properties that are shared have a lock icon on the right
and cannot be edited.

\textbf{Task 2.} Now with the knowledge of prototypes and shared properties you should be able to design your
pinball machine, so it would look similar to the figure \ref{fig:task_2}. Use the \texttt{Platform} prototype
to build all barriers. Also create the \texttt{Flipper} prototype that would be similar to \texttt{Platform}
prototype, except that it will use the \texttt{textures\textbackslash yellow.jpg} texture from the
\hyperref[sec:archive]{archive} and it will have \textbf{DynamicBody} component instead of \textbf{StaticBody}
component. Create two instances of this prototype called \texttt{LeftFlipper} and \texttt{RightFlipper}.

\textit{Hint: To create the \texttt{Flipper} prototype you can instantiate the \texttt{Platform} prototype and
unlink it from the prototype by clicking the remove button on the right of the \textbf{Prototype} property in
the \textbf{Entity} view. Then modify the entity and create a prototype from it.}

\begin{figure}[ht]
 \begin{center}
  \includegraphics[scale=0.65]{Task2}
 \end{center}
 \caption{Task 2}
 \label{fig:task_2}
\end{figure}

\section{Entity Hierarchy}
As the number of entities in your scene grows, it becomes harder not to get lost. Fortunately, the Ocerus
provides means for hierarchical organization through the \textbf{Hierarchy} view. Unlike file system
organization, each and every entity can become a parent of other entities, so there are no folders in this
concept. In fact, it's not an issue at all. Not only that you can use dummy entities (entities with no
components) as folders, you are even encouraged to do so.

Entities can be organized into a hierarchy by dragging them to their parents. This way you can move any entity
to become a child of another entity. To move the entity to the top of the hierarchy (next to another top level
elements), you need to use the \textbf{reparent up} action a couple of times. Just right click on the entity
and select the \textbf{reparent up} action and the entity will move one level upwards in the hierarchy.

Entities can be also ordered among theirs siblings. Use the \textbf{move up} and \textbf{move down} commands
to move an entity before its preceding sibling or after its succeeding sibling.

\begin{wrapfigure}{r}{0.25\textwidth}
\vspace{-20pt}
\capstart
\begin{center}
  \includegraphics[scale=0.65]{Hierarchy}
 \end{center}
 \vspace{-20pt}
 \caption{Hierarchy View}
 \label{fig:hierarchy}
 \vspace{-10pt}
\end{wrapfigure}

Now try to organize entities in your pinball scene. Create a dummy entity called \texttt{Platforms}, remove
the \textbf{Transform} component by clicking the red cross on the right of the component title in the
\textbf{Entity} view and move all platform entities under the Platforms entity. Do the same with flippers (see
figure \ref{fig:hierarchy}).

To further improve the graphics appearance of our scene, we will add a background picture behind our pinball
machine. Create an entity called \texttt{Background} and add the \textbf{Sprite} component to it. Use the
\texttt{background.jpg} image as its texture. Notice that the \texttt{Background} entity is displayed above
your pinball machine. So far we didn't have to take the entities' sprite order into account, but now we need
to make sure that background stays behind the pinball machine. This can be achieved by using layers.  

\section{Using layers}

If you look at the \textbf{Layers} view, you can see the \texttt{Initial Layer} there. Every scene has to have
at least one layer and this one is automatically created. You can click on the plus sign on the left of the
layer name to expand it. Every entity that you created so far is located in this layer. To make sure that our
\texttt{Background} entity will stay behind all other entities, you have to create a new layer.

To create a layer, right click on an existing layer in the layer view and select the \textbf{new layer}
command. A prompt asking for the layer name will pop up. Type \texttt{Background} and click the \textbf{OK}
button. In case the \texttt{Background} layer is not under the \texttt{Initial Layer}, use the \textbf{move
down} command in the layer's context menu. Finally expand both layers and drag the \texttt{Background} entity
to the background layer (or use the \textbf{move down} command in the entity's context menu).

Notice that the initial layer is printed in boldface. This means that the initial layer the active one. If you
are selecting an entity in the editor viewport, only entities in the active layer are selectable. To switch
the active layer, double click on the another layer and it becomes active. You can also toggle the layer
visibility by clicking the eye icon on the right of the layer.

The graphical appearance of our scene is done, as well as the physics in our scene. Now it's time to write the
underlying scripts to implement the game logic.

\section{Scripting}
Ocerus engine allows to implement the game behavior using the scripting engine. Although writing scripts is
indeed programming, it differs from core Ocerus programming in many ways. First, Ocerus scripting environment
was designed for game designers, rather than senior C++ programmers. It does not overwhelm you with
unnecessary complexity of the "guts" of the engine, but it rather provides only the relevant means that are
used in most cases. Also the scripting language is simpler than C++.

We are going to implement the main control of our game - the flippers. Make sure that you have already created
the \texttt{Flipper} prototype, as well as both \texttt{Flipper} entities. Now select the \texttt{Flipper}
prototype and add the \textbf{Script} component to it.

The \textbf{Script} component allows to implement a custom behavior using the scripting language. As soon as
you add the component, you can see the \textbf{ScriptModules} property in the \textbf{Entity} view. This
property contains a list of script files that are associated with this entity. Now it's time to create our
little script. Open your favorite text editor and copy the following code (or use the
\texttt{scripts\textbackslash flipper.as} file from the \hyperref[sec:archive]{archive}).

\lstinputlisting[language=c,
	basicstyle=\scriptsize,
	stringstyle=\ttfamily,
	showstringspaces=false,
	breaklines=true,
	caption=flipper.as,
	label={flipper.as}]{archive/scripts/flipper.as}

Now save the file as \texttt{flipper.as} and copy it into the \texttt{scripts} subdirectory in your project.
Back in Ocerus, select the \texttt{Flipper} prototype and click the \textbf{Add} button next to the
\textbf{ScriptModules} property. Drag the \texttt{flipper.as} resource from the \textbf{Resources} view to the
\textbf{NULL} field in the modules list and click the \textbf{Save} button.
%TODO revidovat jakmile se opravi manipulace s poli (ikonky misto Add, Rvrt, Save).
If everything went well, your script gets loaded and a couple of new properties appear in the \textbf{Script}
component part of the \textbf{Entity} view. These properties are defined in the script and they allow to
parametrize the scripted behavior. In our script, there are two properties: \textbf{LeftSided} and
\textbf{Pivot}. The \textbf{LeftSided} property determines which flipper is the left one and which is the
another one and the \textbf{Pivot} property defines the location of the pivot point.

Select the \texttt{LeftFlipper} entity and check its \textbf{LeftSided} property checkbox. 
%TODO jak nastavit spravne Pivot?? metodou pokus omyl?

When you are ready, you can see your flippers in action. Start the action by pressing the \textbf{Play} button
on the toolbar and try to control your flippers with the \textbf{Left} and the \textbf{Right} key.

To get more info on how to write scripts please see the \texttt{\href{run:./ScriptReference.html}{script reference}} documentation.


\subsection{Includes}
Including other script files is a bit advanced concept which you don't necessarily need to understand but which comes handy from time to time. It allows you to split the code into better manageble chunks and share functionality with other script files. You can include another script file into the current file by placing the following line to the top of the file:
\begin{verbatim}
#include "fileToInclude.as"
\end{verbatim}
What the command does is it basically pastes the content of \texttt{fileToInclude.as} at the position of the command in the current script file. So when you use this command in multiple script files you can share the code inside \texttt{fileToInclude.as}. Note that the included file must contain the full path in the project folder.










\section{GUI}
The last topic that is covered in this user guide is the GUI creation. The Ocerus uses the CEGUI library that
provides the GUI functionality. It uses several files that define particular building blocks of your GUI.
These are the \textbf{Looknfeel} files, the \textbf{Font} files, the \textbf{Imageset} files, the
\textbf{Layout} files and the \textbf{Scheme} files. All these files can be edited with a simple text editor
as they are just XML files, however CEGUI provides visual editors for some of them, namely Layout editor and
Imageset editor.

The \textbf{Looknfeel} files define the visual appearance of the GUI elements. As a reasonable default
\textbf{Looknfeel} is provided to you, we will not cover editing these files. You can find more on this topic
in the \href{http://www.cegui.org.uk/api_reference/fal_man.html}{CEGUI manual}.

The \textbf{Font} files allow to define fonts for your GUI, whether they are TrueType fonts or bitmap fonts.
Again, the Ocerus provide a reasonable default font so neither \textbf{Font} files are discussed in detail
here. See the \href{http://www.cegui.org.uk/api_reference/xml_font.html}{CEGUI manual} to get more info on
\textbf{Font} files.

The \textbf{Imageset} files allow to define your custom images that can be used in GUI. CEGUI allows to put
multiple images into a large image file and specify which parts of the large image correspond to particular
images. This map is defined in \textbf{Imageset} files. In our \texttt{Pinball} project, we will define faces
of two buttons that allow to trigger flippers by clicking them. Look at the \textbf{Imageset} file for our
buttons.
\lstinputlisting[language=xml,
	basicstyle=\scriptsize,
	stringstyle=\ttfamily,
	showstringspaces=false,
	breaklines=true,
	caption=buttons.imageset,
	label={buttons.imageset}]{archive/gui/buttons.imageset}

The \texttt{Imageset} tag of the \textbf{Imageset} file specifies the name of the \textbf{Imageset} and the
file that contains the images. It consists of several \texttt{Image} tags, that specify the particular images;
their name, size and position within the file.

The \textbf{Layout} files define the layout of your GUI elements. Take a look at the \textbf{Layout} file for
our scene that defines two flipper buttons. For now you can just use it as it is and we'll explain what it does later.
\lstinputlisting[language=xml,
	basicstyle=\scriptsize,
	stringstyle=\ttfamily,
	showstringspaces=false,
	breaklines=true,
	caption=gameplay.layout,
	label={gameplay.layout}]{archive/gui/gameplay.layout}

Finally, the purpose of the \textbf{Scheme} files is to group other data files and resources together, and to
define some of their interactions. It usually contains a list of \textbf{Imageset}, files \textbf{Font} files
and \textbf{Looknfeel} files.

However, so far we've only covered how the GUI looks but we still need to connect its events to gameplay. This is done using callbacks into a script. In our case we have the following script which reacts on button presses.
\lstinputlisting[language=c,
	basicstyle=\scriptsize,
	stringstyle=\ttfamily,
	showstringspaces=false,
	breaklines=true,
	caption=gameplay.as,
	label={flipper.as}]{archive/gui/gameplay.as}
You may have noticed that the GUI windows above contain the \textbf{Event} element. What it does exactly is described in the sections below but basically when the event is generated it attempts to execute the given function in the callback script attached to the layout.	

To add the GUI to the project, copy the \texttt{gui} directory from the \hyperref[sec:archive]{archive} to the
project directory. Then switch back to the Ocerus and look at the \textbf{Resources} view. Ocerus tries to
auto-detect types of the resources and usually does a great job. However, when it encounters the \texttt{.png}
file, it identifies it as a \textbf{Texture} resource. To make it work with CEGUI, the type of these image
files needs to be changed to the \textbf{CEGUI} resource. Right click the \texttt{buttons.png} file in the
view and select the \textbf{Change Type $\to$ CEGUI} from the context menu. Now you are ready to put the
layout with flipper buttons into the scene.

GUI layouts that are visible in your games are included into a scene by creating an entity with the
\textbf{GUILayout} component. Create an entity named \texttt{GUILayout}, remove its \textbf{Transform}
component and add the \textbf{GUILayout} component. Look at its properties
(figure~\ref{fig:guilayout_component}).

\begin{figure}[htb]
 \begin{center}
  \includegraphics[scale=0.65]{GUILayout}
 \end{center}
 \caption{GUILayout component}
 \label{fig:guilayout_component}
\end{figure}

First, drag the \texttt{pinball.scheme} file from the \textbf{Resource} view to the \textbf{Scheme} property
in the \textbf{Entity} view. Then drag the \texttt{gameplay.layout} file to the \textbf{Layout} property. Now drag the \texttt{gameplay.as} script to the \textbf{Callback} property.
Finally check the \textbf{Enabled} and \textbf{Visible} checkboxes. Now if you start the game the GUI should be working as promised!


\subsection{Layout}
Now it's time to understand what the layout file actually does and how it is structured. The GUI layout for the game should be defined in a file with the \texttt{.layout} extension and the XML internal structure. Since the CEGUI library is used for the GUI system a layout must fulfill its specification. It is broadly described in its documentation, so here's only a short description.

The \verb/<GUILayout>/ element is the root element in layout XML files. It must contain a single \verb/<Window>/ element representing the root GUI element. The \verb/<Window>/ element must have the \verb/Type/ attribute which specifies the type of the window to be created. This may refer to a concrete window type, an alias, or a falagard mapped type (see the next paragraph). It can also have the \verb/Name/ attribute specifying a unique name of the window. This element may contain \verb/<Property>/ elements with the \verb/Name/ and \verb/Value/ attributes. They are used to set properties of the window. It may also contain \verb/<Event>/ elements with the \verb/Name/ and \verb/Function/ attributes which are then used to create bindings between the window and script functions (see the next section). Also, it can contain another \verb/<Window>/ elements as its child windows. For supported window types, properties and events see the CEGUI documentation.


\subsection{String files}
Note that there's a feature of the layouts specific to this engine. That is the translation of texts. While using the \verb/Text/ and \verb/Tooltip/ properties you can surround the value by \$ (i.e. \verb/Text=$text$/). That text is then used as a key to search for the text in the \verb/GUI/ group of the string manager. The string manager automatically loads the string files in the \verb/strings/ directory according to the currently selected language. More on that in the sections below.


\subsection{Events}
To be able to react when a user does something with the GUI you must connect the GUI layout to scripts. This can be done by placing the script into the \textbf{Callback} property of the \textbf{GUILayout} component. To subscribe to an event add the \textbf{Event} element to the window. Use its \textbf{Name} attribute to specify the event you want to react on. Use the \textbf{Function} attribute to set the name of the function in your script which will be executed when the event fires. The function must take a single parameter of the \textbf{Window@} type which holds a reference to the window which generated the event.

For example assume this is a part of a layout

\begin{verbatim}
<Window Type="CEGUI/PushButton" Name="Continue">
  ...
  <Event Name="MouseClick" Function="ContinueClick">
  ...
</Window>
\end{verbatim}

\noindent and this is a part of a script module

\begin{verbatim}
void ContinueClick(Window@ window)
{
  Println(window.GetName());
}
\end{verbatim}

\noindent connected via the \textbf{GUILayout} component together. The component can be in any active entity in the scene. Then  every click on the button named \textbf{Continue} will print the message \textbf{Continue} into the log.


\section{Strings}
In the game you sometimes want to tell the player something. To keep the project manageable it's better to separate the strings from the rest of the game. To do that the engine loads strings from the text files in the \texttt{strings/} directory. By default only the \texttt{GUI.str} file is there. If you open it you'll see it has a very simple structure. It consists of text items and comments. The pattern of a text item is \textbf{Key=Value}, where \textbf{Key} is an ID that is used for indexing a text represented by \textbf{Value}. If the \textbf{Key} contains the \textbf{group} value it places all texts under it into the group defined by \textbf{Value}. The \textbf{Key} must be unique within a group. Comments start with the \verb/#/ character. Here is an example of a correct text file:

\begin{verbatim}
# the name of the group to which the following texts belong
group=ExampleGroup
# comment to the text item below
example_key=Example text.
another_key=Another text.
\end{verbatim}

The encoding of text files must be ASCII or UTF8. It is possible to end lines in Windows (\verb/\r\n/) or UNIX (\verb/\n/) style.



\section{Directory layout}
\label{sec:dir-layout}

The directory in which the text files are stored must follow a specific layout. In the root directory there are files with default language texts. These texts are used when the engine can't locate the text in the subdirectory of the current language. These subdirectories should contain the same files as the root directory. If any text varies in countries that use a common language it should be placed in a subdirectory of the language directory. It is recommended that the language and country names correspond with common norms. Here is an example of a directory layout:

\begin{verbatim}
-en
 -GB
  -textfile.str (1)
 -US
  -textfile.str (2)
 -textfile.str  (3)
-fr
 -textfile.str  (4)
-textfile.str   (5)
\end{verbatim}

\noindent Assume that the files from the above example have the following content:

\begin{verbatim}
(1)
group=Group
country_specific=Country
(3)
group=Group
language_specific=Language
country_specific=Language
(5)
group=Group
default_string=Default
language_specific=Default
country_specific=Default
\end{verbatim}

\noindent Now this table shows what will be actually displayed for different languages.\newline
	\begin{tabular}{|l|l|}
	\hline
	Text ID & Text value\\
	\hline
	\multicolumn{2}{|c|}{\emph{Language: en-GB}}\\
	\hline
	default\_string & Default\\
	language\_specific & Language\\
	country\_specific & Country\\
	\hline
	\multicolumn{2}{|c|}{\emph{Language: en}}\\
	\hline
	default\_string & Default\\
	language\_specific & Language\\
	country\_specific & Language\\
	\hline
	\multicolumn{2}{|c|}{\emph{Language: default}}\\
	\hline
	default\_string & Default\\
	language\_specific & Default\\
	country\_specific & Default\\
	\hline
	\end{tabular}



\section{Conclusion}
Ok this is it! Now you have your first game fully working. What we've shown you is just a basic functionality of the editor but you can do much more, of course! The scripting system together with components is quite powerful to allow you to build different types of games. It might be also useful for you to take a look at the \textbf{Cube} project and explore what it actually does. Also, listed below are few sections about some general topic related to the editor itself and its behaviour from the user point of view.





\appendix



\section{Resources archive}
\label{sec:archive}
Resources needed to create the game described in this guide are accompanying the PDF. If you have opened the
guide from the editor, the resources are likely to be in the \texttt{\href{run:./archive/}{archive}}
directory. Otherwise, you need to download the archive package from the project website. See the
\href{http://sourceforge.net/projects/ocerus/files/}{Ocerus download page}.



\section{Supported formats}
\label{sec:supported_formats}
Ocerus supports following file formats in your games.\\
\\
Texture resources: JPEG, PNG, TGA, BMP, PSD, DDS, HDR \\
Model resources: OBJ\footnote{Content of the corresponding MTL file must be inserted to the beginning of the file. When exported from Blender, following options should be checked: "Copy Images", "Normals", "Polygroups", "Objects", "Groups", "Material Groups".} \\
CEGUI image resources: JPEG, PNG, TGA



\section{Editor controls}
\label{sec:editor_controls}
In this part you can see the description of all features the editor can perform using menus and other mouse actions. First of all take a look at picture \ref{fig:editor_description}. There you can see parts of the editor which will be described in the sections below. What is not visible in the picture is a developer console. It can be opened and close by pressing the ` key.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=\textwidth]{EditorDescription}
 \end{center}
 \caption{Different parts of the editor}
 \label{fig:editor_description}
\end{figure}


\subsection{Main menu}
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			File & Function\\
			\hline
			Create Project & creates a new project with default resources\\
			Open Project & open an existing project from a folder location; the editor will need the project.ini file there\\
			Close Project & closes the current project\\
			Deploy Project & opens a dropdown menu with available platforms; after clicking on a platform and choosing a folder the application will be deployed there for the given platform\\
			Quit & saves the project and closes the editor\\
			\hline
			Scene & Function\\
			\hline
			New Scene & creates an empty scene of the specified name\\
			Open Scene & opens a list of available scene; opens the scene after you click it\\
			Save Scene & saves the current scene\\
			Close Scene & closes the current scene\\
			\hline
			Edit & Function\\
			\hline
			New Entity & creates empty entity at the zero position\\
			New Component & after you select the component type from the dropdown list it will be added to the current entity\\
			Duplicate Entity & creates new entity identical to the currently selected at the place of the old entity\\
			Duplicate Selected Entities & if you have multiple entities selected this will duplicate them all\\
			Delete Entity & deletes the currently selected entity\\
			Delete Selected Entities & if you have multiple entities selected this will delete them all\\
			Create Prototype & creates a prototype from the currently selected entity; the entity will be automatically linked to the prototype\\
			\hline
			Help & Function\\
			\hline
			About & info about the application\\
			User Guide & this very document\\
			Shortcuts & a list of shortcuts available from the editor\\
			Script Reference & reference manual to the script system\\
			Extending Ocerus & a document describing how to extend the funcionality of the engine\\
			Design Documentation & a document describing the architecture of the engine and its parts\\
			Doxygen & reference manual to the C++ engine classes\\
			\hline
			
		\end{tabular}


\subsection{Toolbar}
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			Action & these buttons control the game action\\
			\hline
			Play & starts or resumes the action; objects start moving\\
			Pause & pauses the action if it's running\\
			Restart & stops and rewinds the action; objects are reset to their state prior to the action start\\
			\hline
			Tools & these buttons control the current mouse edit tool\\
			\hline
			Move & mouse dragging moves selected objects\\
			Rotate & mouse dragging rotates selected objects\\
			Rotate Z & mouse dragging rotates selected objects along the Z axis; it's visible only if the objects have the Model component\\
			Scale & mouse dragging scales the selected objects along the X and Y axes\\
			\hline
			
		\end{tabular}


\subsection{Entity view}
The entity view displays a list of components. Each component is represented by a box with a title of the type of the component. Inside of each of the boxes there's a list of their properties. You can influence the behaviour of components by changing these properties. You can do this from the editor but also from scripts.

There are different types of properties. Most of them can be edited as text, so you can just click them and type in the new value. And the boolean property can be changed by clicking on its checkbox. However, the resource property cannot be changed directly. To change it you must drag there a resource from the Resource view using your mouse and release it onto the property. The same way you take care of the prototype property (in the General component box) but instead of a resource you drag there an entity from the Prototype view. The layer property can only be changed by moving the object to a different layer in the Layer view.

Some of the properties cannot be changed at all. To find out read the property description. Hover your mouse over the property and wait until a tooltip with the description appears. Also, if the entity is linked to a prototype some of its properties might be marked as \emph{shared}. It means that all prototype instances share the property and it can only be changed in the prototype itself. To know if a property is shared or not see if there's a lock icon next to it in the Entity view. You can mark/unmark properties shared if you select the prototype in the Prototype view. Then all of the properties has a checkbox next to them which does this thing.

When you save the scene all components and properties are automatically saved into the scene file. So when you reload the scene the properties get restored again. However, this doesn't work when the game action is running. After you restart the action all objects and properties get reset to the values before the action started.


\subsection{Hierarchy view}
Here you can see all entities in the game structured as a tree. If you click an item the entity gets selected and will appear both in the Entity view and in the Editor viewport as such. If you double-click the item the Editor viewport will pan to the entity (if it has the Transform component, so to speak). You can drag the entities around in the Hierarchy view to change the structure of the tree. Right-clicking an item will bring up the following menu:
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			Move Up & moves the entity up in the list\\
			Move Down & moves the entity down in the list\\
			Reparent Up & moves the entity up in the hierarchy\\
			Add Entity & creates an empty entity as a child of the current entity\\
			New Component & adds a component to the entity\\
			Duplicate Entity & duplicates the entity placing it at the same level in the hierarchy\\
			Delete Entity & deletes the entity\\
			Create Prototype & creates a prototype from the entity and links the entity to it\\
			\hline
		\end{tabular}


\subsection{Game viewport}
In the Game viewport the game is displayed as it will look in the result. Once the action is started (using the Toolbar) you can use your mouse and keyboard the same way you'll use them in the final game. Some editor controls and shortcuts are blocked until the action is paused or restarted.


\subsection{Editor viewport}
The Editor viewport allows you to select and edit entities and see the changes in the Game viewport. You can pan the camera unsing the arrow keys or by holding the middle mouse button and moving the mouse. Zoom out or in using the mouse wheel. Select entities by left-clicking them. You can select multiple entities by holding the shift key while left-dragging the mouse. Note that you can only select entities in the currently selected layer (in the Layer view). If you have an entity selected you can mouse-edit it by dragging it while the left button is down. The action what happens depends on what edit tool you have selected in the Toolbar. If you right-click and entity a context menu appears. It contains some of the items of the Edit submenu of the Main menu. They behave exactly the same, so read the description of the Main menu for more info.


\subsection{Layers view}
Here you see the list of layers in the game. Each entity must belong to a layer. Layers define what gets drawn first and also you can use them to filter out collisions. The topmost layer is drawn last. The current layer is displayed bold. You can change it by double-clicking another layer. If you click on the + button the layer gets unrolled, so you can see all entities in the layer. You can hide or show the layer by clicking the eyes icon. If you right-click a layer the following menu appears:\newline
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			Move Up & moves the layer up in the list\\
			Move Down & moves the layer down in the list\\
			New Layer & adds new layer below the clicked one\\
			Rename & renames the layer\\
			Remove & deletes the layer\\
			\hline
		\end{tabular}


\subsection{Prototypes view}
This view lists all entity prototypes of the project. Note that the prototypes don't exist in any scene. They are global for the project. To instantiate a prototype you can use the context menu or you can just drag it to the Hierarchy view or the Editor viewport. You can also drag it to the prototype property of an entity in the Entity view. This will link the entity to this prototype. You can create prototypes either by using the prototype context menu (to create an empty one) or by using the context menu of an entity or the Edit submenu of the Main menu (to create the prototype based on the entity). Righ-clicking the Prototype view brings the following menu:\newline
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			Create Entity & instantiates the prototype into a new entity; it appears at the bottom of the Hierarchy view\\
			Add Prototype & creates an empty prototype\\
			Delete Prototype & deletes the prototype and unliks all its instances\\
			\hline
		\end{tabular}
		
		
\subsection{Resources view}
Here you can see all resources usable in the project. It lists them in the same structure as they reside on the disk in the project folder. You can open a resource by double-clicking it. The default system editor will start. The exception is a scene resource which will open the scene in the editor. You can drag a resource to a resource property in the Entity view to change its value. Each of the resources has a specific type which limits its use in the project. The type is designated by an icon next to the resource name. The resource types are assigned automatically but you can force the change using the context menu:\newline
		\begin{tabular}{|p{0.23\hsize}|p{0.70\hsize}|}
			\hline
			Change Type & opens a list of available types for this resource; the current type has an asterix next to the name\\
			Open Scene & opens the resource as a scene if it is a scene\\
			Rename Scene & renames the resource as a scene if it is a scene\\
			\hline
		\end{tabular}


\subsection{Developer console}
The console can be opened and closed by pressing the ` key. It displays the editor log. It is usefull to see what's going on in the editor as well as scripts. If there is an error in the script it will be displayed here. Note that the editor log is automatically saved in the current folder in the \emph{Core.log} file.

You can also use the console to try simple script commands. Simply type the command into the edit box and press enter. The command will get compiled and immediately executed.



\end{document}
