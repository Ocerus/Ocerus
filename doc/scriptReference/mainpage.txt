
/** 

@mainpage Ocerus Script Reference
  
  
@section intro Introduction
  
This is a reference manual to the scripting language used in Ocerus. To see the C++ reference manual to Ocerus
visit <a href="../Doxygen.html">doxygen</a>.

The scripting language used is <a href="http://www.angelcode.com/angelscript/">AngelScript</a>. This manual
describes only functions specific to Ocerus. To see the documentation to the language itself (including
the syntax, default types and constructs, built-in functions, etc.) visit
the <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/index.html">AngelScript manual</a> homepage.
A very brief overview of AngelScript is given @ref angelscriptbasics "below". 


@section notice Important Notice

Please note that since Doxygen doesn't support the @ character (object reference) it was replaced by * in
the documentation. However, when you write the code you must use @ instead. AngelScript doesn't use *. 



@section howtowrite How to write scripts

First of all make sure to read the <a href="../UserGuide.pdf">user guide</a> which will teach you how to create
and set up a project and create your first script. Script are connected to the other parts of the engine
by using entity components. So to write a script you add a component to the entity related to your script.
Then link the script file to the component by dragging it there from the resource window. Once this is done
you can change the script file and when you save it it automatically reloads in the game as well.



@section wheretostart Where to start?

To write some code you need a point of entry. Often this is the "void main()" functions but not here.
Every code gets executed only as a reaction to an event. These events are generated by entities sending
messasges among themselves. So, the best place to start is to see what
<a href="group__events.html">event handlers</a>
are available from the scripts and write some code (like ::Println()) into them to see if it works. Then
you can browse other classes and functions to add your functionality. Make sure you also see
<a href="group__globals.html">global functions and variables</a>.
If you're not familiar with AngelScript yet you may want to read the @ref angelscriptbasics "basics".



@section customvariables Using custom variables

Sometimes it's necessary to declare your own variables which last outside functions and handlers. You
could use global variables as defined in AngelScript but it's not the recommended solution since they
are also shared among all instances of the script. So if you have multiple entities using the same
script file they will all share the values of the variables.

Instead it's better to create the variable as a dynamic property using methods such as
EntityHandle::RegisterDynamicProperty_bool(). These variables then appear in the entity editor window as well as
common properties and the user can see or edit them. This way the user can influence the behavior
of your script and it makes it easier to re-use the script.



@section angelscriptbasics AngelScript Basics

This is a brief description of the capabilities of AngelScript. The script language resembles
the C++ language but there are some differences and limitations which are
described in the next paragraphs.

It is not possible to declare function prototypes, nor is it necessary as
the compiler can resolve the function names anyway. For parameters sent
by reference it is convenient to specify in which direction the value is passed
(&in for passing to function, &out for passing from function and &inout for
both directions) and whether it is constant (const before type).

It is possible to declare script classes like in C++ but there are no visibility
keywords (everything is public) and all class methods must be declared with
their implementation (like in Java or C#). Operator overloads are supported.
Only the single inheritance is allowed but polymorphism is supported by
implementing interfaces and every class method is virtual. The automatic
memory management is used so it can be difficult to know exactly when the
destructor is called but it is called only once.

Because pointers are not safe in a script environment the object handles
(class@ object;) are used instead. They behave like smart pointers that
control the life time of the object they hold. There are initialized to null by
default and can be compared by is operator (if (a is null) \@a = \@b;).
Every object of a script class is created as a reference type while the objects
of a registered class can be created as a value type (see section 10.4.1 for
more information).

Primitive data types are the same as in the game engine (for example uint8
for an unsigned 8-bit integer, float64 for a 64-bit real number). Arrays are zero
based and resizeable (they have methods length() and resize(uint32)).
It is also possible to define C++ like enumerations and typedefs (only for
primitive types).

*/
