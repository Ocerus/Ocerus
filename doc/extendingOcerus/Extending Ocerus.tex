\documentclass[a4paper, 12pt]{report}

\usepackage[USenglish]{babel}
\usepackage[T1]{fontenc}
\usepackage[ansinew]{inputenc}
\usepackage{lmodern} %Type1-font for non-english texts and characters
\usepackage{graphicx}

\newenvironment{titled-itemize}[1]
{
\vspace{5mm}
\noindent\emph{#1}
\begin{itemize}
}
{
\end{itemize}
}

\begin{document}

\pagestyle{empty} %No headings for the first pages.

\title{Guide for extending the Ocerus project}
\author{Lukas Hermann, Ondrej Mocny, Tomas Svoboda, Michal Cevora}

\pagestyle{plain} %Now display headings: headings / fancy / ...

\tableofcontents %Table of contents
\cleardoublepage %The first chapter should start on an odd page.

\chapter{Introduction}

The project Ocerus was designed to be easily extendable on well defined places in code. It allows developers to create even more diverse games. This document serves as a cookbook and shows a sequence of steps that will lead to extension of the Ocerus. There are several ways of extending the Ocerus. Each way will be discussed in separate chapters.

This document only shows how to make things work. If you want to understand how they work, you should see the Design documentation.

\chapter{Components}

Probably the first thing you would like to extend are the components. They can easily add functionality to game entities. Similar result can be achieved by using scripts but the logic in components is not limited to predefined script functions and runs faster. In the following sections, there will be a sequence of steps that are necessary  to do in order to create and use new component. 

There will be also an example of simple component that will make an entity to move up and down. It would probably be better to implement this functionality by a script but it will serve well as a simple example.

\section{Creating Component Class}
The first thing that needs to be done is creating new component class. Each component class is defined in separate header file, which are located in \emph{EntitySystem/Components}.

The header file of a component must be defined in the \emph{EntityComponents} namespace and must publicly inherit from the  \emph{RTTIGlue< [Component Name], Component>}. So the example component class would look like this:

\begin{verbatim}
namespace EntityComponents
{
  class ExampleComp : public RTTIGlue<ExampleComp, Component>
  {
  }
}
\end{verbatim}

There are few methods in this class that should be overridden. Namely, \emph{Create}, \emph{Destroy}, \emph{HandleMessage} and \emph{RegisterReflection}. \emph{Create} and \emph{Destroy} methods are called after the creation respectively before the destruction of the component. \emph{HandleMessage} and \emph{RegisterReflection} method will be described in a later sections.

Then, the component type must be registered in the \emph{\_ComponentTypes.h} header file (located in \emph{EntitySystem/Components}). New line \emph{COMPONENT\_TYPE(ExampleComp)} should be added.

Finally the header file with the component class must be included in the \emph{\_ComponentHeaders.h} header file.

\section{Adding Component Properties}

The component properties are represented by class members. But just defining a class member is not enough to make it into a regular property. It needs to be registered in the RTI. Registering properties is done in static method \emph{RegisterReflection}. It is called during the initialization process of the \emph{EntitySystem}. In this method, there should be called the \emph{RegisterProperty} function. Usage of that function looks like this:

\begin{verbatim}
RegisterProperty<Property type>("Property name", &GetterMethod, 
  &SetterMethod, Access flag, "Property description");
\end{verbatim}

\begin{itemize}
\item
The Property type is obviously the data type of the property but is must be registered in the \emph{PropertyTypes.h} header file (located in \emph{Utils/Properties}). All regular property types are already registered there. There is also a short description of how to register new property types.

\item
The property must have defined getter and setter methods. The methods signatures must look like this:

\begin{verbatim}
[Property type] GetProp(void) const
void SetZoom([Property type] value)
\end{verbatim}

Addresses of those methods must be given as parameters to the \emph{RegisterProperty} function.

\item
The Access flag defines ways how the property can be accessed from the editor or a script or whether it should be saved/loaded to/from stream. The list of all flag states is in the \emph{PropertyAccess.h} header file (located in \emph{Utils/Properties}).
\end{itemize}

There can be also functions registered in order to be called from scripts. For that, there is the \emph{RegisterFunction} function. Usage of that function is similar to the \emph{RegisterProperty} and looks like this:

\begin{verbatim}
RegisterFunction("Function Name", &Function, Access flag,
  "Function description");
\end{verbatim}

Back to the example component. Let's say it will have three properties and one function. One property for the amplitude, second for the period of moving, third for the timer and function for reseting the timer. All three properties will be of the float32 data type. Setters and getters must be defined as well as the \emph{RegisterProperty} function. 

The example component needs to access and change the position of the entity. The position is defined in the \emph{Transform} component. To ensure that the entity have \emph{Transform} component, the dependency must be added. For that purpose serves the \emph{AddDependency} function. It receives a component type as a parameter (component type is defined as \emph{CT\_[Component class name]}). It will also force the dependent component to initialize later than the other component.

So the example component class will look like this: 

\begin{verbatim}
namespace EntityComponents
{
  class ExampleComp : public RTTIGlue<ExampleComp, Component>
  {
  public:
    virtual void Create(void){mAmplitude = mPeriod = mTimer = 0;}
    virtual void Destroy(void){}

    void Reset(void)
    {
       mTimer = 0;
    }

    static void RegisterReflection(void)
    {
      RegisterProperty<float32>("Amplitude", &GetAmplitude,
        &SetAmplitude, PA_FULL_ACCESS, "Amplitude of moving.");

      RegisterProperty<float32>("Period", &GetPeriod, 
        &SetPeriod, PA_FULL_ACCESS, "Period of moving.");

      RegisterProperty<float32>("Timer", &GetTimer, 
        &SetTimer,PA_FULL_ACCESS,"Time from the start.");

      RegisterFunction("Reset", &Reset, PA_SCRIPT_WRITE,
        "Resets the timer.");

      AddComponentDependency(CT_Transform);
    }

    float32 GetAmplitude(void) const { return mAmplitude; }
    void SetAmplitude(float32 value) { mAmplitude = value; }
		
    float32 GetPeriod(void) const { return mPeriod; }
    void SetPeriod(float32 value) { mPeriod = value; }
		
    float32 GetTimer(void) const { return mTimer; }
    void SetTimer(float32 value) { mTimer = value; }

  private:
    float32 mAplitude;
    float32 mPeriod;
    float32 mTimer;
  }
}
\end{verbatim}

\section{Entity Messages}

Entities can receive messages. They are sent by the engine when some event occurs. It can be initialization of the entity, update in physics, pressed key etc. Messages can be also sent from a script.

A message that is sent to an entity is distributed to all its components. It can also carry parameters.

\subsection{Message Types}
Message types are defined in the \emph{EntityMessageTypes.h} header file (located in \emph{EntitySystem/EntityMgr}). New message types can be easily added if needed. Declaration of the message type is done by macros and looks like this:

\begin{verbatim}
ENTITY_MESSAGE_TYPE([Name], "[Script function]", [Parameters] )
\end{verbatim}

\begin{itemize}
\item
Name is simply name of the message type. Must be unique.
\item
If an entity has a script component, then when it receives a message, a function in script is called. And that functions name and signature is defined by the second parameter in the \emph{ENTITY\_MESSAGE\_TYPE} macro.
\item
The third parameter defines parameters that can be added to the message. When no parameter is needed, then \emph{NO\_PARAMS} macro should be used. Otherwise, the \emph{Params} macro should be used. It accepts property types as parameters. So a message with float32 and int32 parameters will have \emph{Params(PT\_FLOAT32, PT\_INT32)}.

Note that the parameters must correspond to the script function signature defined in the second parameter of \emph{ENTITY\_MESSAGE\_TYPE} macro. So it could look like this: 

\begin{verbatim}
ENTITY_MESSAGE_TYPE(HELLO, "void Hello(float32, int32)",
  Params(PT_FLOAT32, PT_INT32) )
\end{verbatim}

\end{itemize}

\subsection{Handling Messages}

 The handling of messages is done by the \emph{HandleMessage} method of the component class. It accepts \emph{EntityMessage} as a parameter. The \emph{EntityMessage} contains the message type and message parameters. 

The \emph{HandleMessage} method must return result. \emph{RESULT\_OK} if the message was accepted, \emph{RESULT\_IGNORED} when the message was ignored and \emph{RESULT\_ERROR} if an error occurred.

The example component, which makes an entity to move up and down, could have the \emph{HandleMessage} method implemented like this:

\begin{verbatim}

EntityMessage::eResult EntityComponents::ExampleComp::
  HandleMessage( const EntityMessage& msg )
{
  switch (msg.type)
  {
  case EntityMessage::INIT:
    {
      // Get transform component
      Component* transform = gEntityMgr.
        GetEntityComponentPtr(GetOwner(), CT_Transform);
      // Get position property from component
      // mStartPosition must be declared as a member variable
      mStartPosition = transform->GetProperty("Position").
      GetValue<Vector2>();

      return EntityMessage::RESULT_OK;
    }
  case EntityMessage::SYNC_PRE_PHYSICS:
    {
      // Get first (and only) message parameter
      float32 delta = *msg.parameters.GetParameter(0).
        GetData<float32>();

      if ((delta <= 0)|| (mPeriod <= 0))
        return EntityMessage::RESULT_OK;

      mTimer += delta;

      // Calculate an offset from the start position
      float32 offset = mAmplitude * 
        MathUtils::Sin(mTimer / mPeriod * 2 * MathUtils::PI);

      Component* transform = 
      gEntityMgr.GetEntityComponentPtr(GetOwner(), CT_Transform);

      Vector2 pos = mStartPosition;
      pos.y += offset;

      // Set new value to the position property
      transform->GetProperty("Position").SetValue(pos);

      return EntityMessage::RESULT_OK;
    }
    default:
      return EntityMessage::RESULT_IGNORED;
  }
}
\end{verbatim}

\chapter{Scripts}

\section{blabla}

\chapter{Resource Types}

\section{blabla}

\chapter{Renderer}

\section{blabla}

%% A small distance to the other stuff in the table of contents (toc)
\addtocontents{toc}{\protect\vspace*{\baselineskip}}

%% The Bibliography 
\begin{thebibliography}{9}
\addcontentsline{toc}{chapter}{Bibliography} %'Bibliography' into toc
\bibitem {angelscript}AngelScript -- http://www.angelcode.com/angelscript

\end{thebibliography}

%% The List of Figures
\clearpage
\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures

%% The List of Tables
\clearpage
\addcontentsline{toc}{chapter}{List of Tables}
\listoftables

\end{document}